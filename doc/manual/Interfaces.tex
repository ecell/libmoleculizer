\chapter{Libmoleculizer Interfaces}
\label{chap:interfacesChapter}

Libmoleculizer has multiple wrappings that allow users of different
languages -- C++, C, or Python -- to use rule-based reaction network
generation in their own programs.  This chapter describes these
interfaces and how to use them, and is followed by a section
discussing how to extend this procedure to new languages.

\subsection{C++ Interface}
The C++ interface is the standard interface for libmoleculizer, as
well as the language that libmoleculizer has been implemented in.
Consequently, the C++ interface is the most powerful as well as the
most detailed. 

The C++ interface controls creating a libmoleculizer intance,
configuring it, loading a rules file into the instance, and expanding
the reaction network out.  The interface also allows inspecting the
network to see whether or not certain species have been created, see
what reactions might be possible for a set of products, as well as
other questions.  These parts are given an overview below, although
for a complete overview of the API, please consult either reference
portions of this documentation, or browse the source code (the
moleculizer interface can be found in src/mzr/moleculizer.hh and
src/fnd/reactionNetworkDescription.hh).


\subsubsection{Overview}
Use of libmoleculizer will usually follow, a ''create, configure,
load, run'' pattern, with the first three parts being relatively
constant from time to time.  

\subsubsection{Create}
To use libmoleculizer in C++ code, a Moleculizer object, which
represents a reaction-network that can be generated, must be
created. This is easy, as Moleculizer only has one constructor:
moleculizer::moleculizer().  An individual wishing to use generative
reaction-networks libmoleculizer library to be used in his/her work
then would begin by creating a moleculizer object.  

\lstset{language=C++}
\begin{lstlisting}[caption=Creating a moleculizer object, label=creatingmzrexample]
mzr::moleculizer m; // Note that this takes place in the namespace mzr,
                    // as does all the C++ interface.
\end{lstlisting}


\subsubsection{Configure}
Now that a new Moleculizer instance has been created, it must be
configured as far as what type of reaction-network expansion to do, as
well as configured to determine how deep to expand the
reaction-network.  

Primary here is to determine whether or not to use spatial or
non-spatial reaction network generation.  In each mode, new species
and new reactions will be generated, however the parameters generated
will be different depending on the case.  Spatial reaction network
generation generates species-reaction networks with parameters
appropriate for simulating the network in a spatial simulator: when a
new species is generated, a mass, species radius, and diffusion
coefficient is generated for that new species, and when a new reaction
is generated, an intrinsic reaction rate is generated for that new
reaction.  In non-spatial mode, parameters appropriate for either a
Gillespie type stochastic simulation or a determanistic ODE simulation
are produced: when a new species is generated, a mass is generated
along with it, and when a new reaction is generated, a reaction rate
is generated along with it.  Please see previous chapters for a
description of these modes.

To configure a moleculizer object to use either of these modes, please
use either the ''enableSpatialReactionNetworkGeneration'' or the
''enableNonSpatialReactionNetworkGeneration(bool)'' functions.  The
boolean parameter needed by
''enableNonSpatialReactionNetworkGeneration'' controls massed-based
extrapolation.  If false, the reaction rate extrapolated for a
reaction is the same as the reaction rate described in the basic
reaction-rule in the model file.  If it is true, the reaction-rate is
modified by a ''mass-correction factor'', as described in the Brent,
Lok paper.  

\lstset{language=C++}
\begin{lstlisting}[caption=Enabling spatial reaction generation]
  mzr::moleculizer m;                          // Create a Moleculizer object.
  m.enableSpatialReactionNetworkGeneration();  // Configure it to generate spatial partameters.
\end{lstlisting}

\begin{lstlisting}[caption=Enabling non-spatial reaction generation]
  mzr::moleculizer m;                                   // Create a Moleculizer object.
  m.enableNonspatialReactionNetworkGeneration( true );  // Configure it to generate non-spatial parameters, using mass-based extrapolation.
\end{lstlisting}

If spatial species-reaction network extrapolation is going to be used,
please note that the 'explicit-species' elements must have an
additional 'parameters' subsection, that provides a diffusion
coefficient for each initial species in the model.  Failure to do so
will result in a runtime error.  Please see the chapter ''Rules'' for
more information.

The second option that can be configured prior to runtime is the
expansion depth of species-reaction generation.  At any given moment,
beginning with the list of explicit-species provided in the rules as
well as the generated set of reactions between them, moleculizer
maintains a generated reaction-network, consisting of a list of
species and a list of reactions.  Some of these species are
'expanded'; that is, Moleculizer has presented each of those species
to the list of species, has generated any new reactions based on them,
and has added the new products of those reactions as 'unexpanded'
species to the list.  Others are 'unexpanded', meaning that the
reactions that species can participate in in, and any subseqeuent
products of those reactions, have not yet been generated and added to
the reaction network generation.  

By default, Moleculizer expands species out to one ply.  This means
that when a species is expanded, new reactions that involve already
expanded species and the species being expanded are created, and
reaction products are added to the network as being unexpanded.  

Higher plys imply more species and reactions are generated with each
expansion step, at the expense of more computational time and memory.
For instance, expanding a species to a ply of two means that new
reactions involving that species are generated, along with reaction
products.  However, each of those products are also expanded.
Expanding each of these products will cause more species and reactions
to be generated.  Expanding to a third-ply will take each of these
species and expand them in turn.  The standard ply of one is fine for
most applications.  However, if desired, it can be checked using the
'getGenerationDepth' function, and set using the
'setGenerateDepth(unsigned int)' functions.  

\lstset{language=C++}
\begin{lstlisting}[caption=Setting a non-default network generation depth]
  mzr::moleculizer m; 
  m.enableNonspatialReactionNetworkGeneration( true );
  m.setGenerateDepth( 5 );
\end{lstlisting}
  


\subsubsection{Loading}
Once configuration parameters have been set up, a model can be
loaded.  This can be accomplished using one of three functions:
\lstinline@attachFileName( const std::string& aFileName )@.
\lstinline@attachString( const std::string& documentAsString )@,
or \lstinline@attachDocument( xmlpp::Document* pDoc )@.  Each of these takes a
model, in one form or another, loads it, parses it, and loads it,
preparing Moleculizer for species and reaction generation.  

A libmoleculizer model is an xml description of basic molecules (mols) and
reaction rules defined in terms of molecules, that usually describe
either protein-protein interactions or enzymatic reactions on
proteins.  A description of the full syntax of these files can be
found in the chapter 'Rules'.  An xml specification can be either
passed to libmoleculizer as a string containing file contents, a path
to a model file, or can be passed in as an xmlpp::Document*
(corresponding to an xml document parsed as a dom object using
libxml++, the xml library used by libmoleculizer).

Use cases:
1.  Model file is contained in a file.
If filePath is a string containing either an absolute or relative path
to the file, then the function moleculizer::attachFileName can be
called as follows.  

\lstset{language=C++}
\begin{lstlisting}[caption=Loading a MZR file into a running
  moleculizer instance]
// Create a new reaction-network generator.
mzr::moleculizer m;

// Setup extrapolation here. 
m.enableSpatialReactionNetworkGeneration(); // For instance.

// Load the file into the moleculizer object.
m.attachFileName( filePath );
\end{lstlisting}

2..Model is contained in a string.
If modelContents is a string containing a model file, then the
function moleculizer::attachString can be used to load this model file
as follows

\begin{lstlisting}[caption=Loading a MZR string into Moleculizer]
// Create a new reaction-network generator.
mzr::moleculizer m; 

// Setup extrapolation here.
m.enableNonspatialReactionNetworkGeneration( true ); // For instance.

// Load the string holding the model file into the moleculizer object.
m.attachString( modelContents );
\end{lstlisting}

3.  Model has already been parsed and is contained in an
xmlpp::Document* object called ptrModelDoc.

\lstset{language=C++}
\begin{lstlisting}[caption=Loading an XML document into moleculizer]
// Create a new reaction-network generator.
mzr::moleculizer m;

// Setup extrapolation here.
m.enableNonspatialReactionNetworkGeneration( false );  // For
instance.

// Load the Document* into moleculizer.
m.attachDocument( ptrModelDocument );
\end{lstlisting}

Any of these will load the necessary information into a model
instance. Note however, that information can only be added into
moleculizer once per instance.  Should the model have to be updated,
the moleculizer object must be destroyed and recreated and loaded with
the new model.  This is not optimal, and may change in upcoming
versions.  Users can determine whether a model is loaded by calling
the ''bool moleculizer::getModelHasBeenLoaded() const'' function.  

\subsubsection{Running}
Once a Moleculizer object has been created, configured, and a
rules-file has been loaded, there are several things that can be done.

The things that can be done are inspecting the species and reactions
that have been generated so far, expanding species and reactions in
order to generate additional portions of the species and reaction
network, inspecting the portion of the species and reaction network
that were created during the most recent expansion phase, and
searching for reactions that match certain parameters.  

The most basic operation that can be performed on a species and
reaction network is simply inspecting its contents.  These can be done
using the interface functions ''getSpeciesCatalog'' and
''getReactionList'' functions.  The 'getSpeciesCatalog' function
returns a map from std::string pointers to mzr::mzrSpecies*.  (Please
note that this map compares pointers based on their dereferenced
values rather than the pointer values themselves.)  By scanning
through this map, users can find out the identities of every species
that has been created, by using its unique identifier.  Using this
map, information can be gained for each species, using the relevant
'getKDForSpecies', 'getRadiusForSpecies', 'getMassForSpecies'
functions.  

\lstset{language=C++}
\begin{lstlisting}[caption=Finding spatial properties of a species
  using moleculizer]
mzr::moculizer m;
m.enableSpatialReactionNetworkGeneration();
m.loadFile(''moleculizer-rules.xml'');

std::pair<std::string, const mzr::mzrSpecies*> speciesPair =
m.getSpeciesCatalog().first;

const mzr::mzrSpecies pSpecies = speciesPair.second;

Real speciesMass = m.getKDForSpecies( pSpecies );
Real speciesRadius = m.getRadiusForSpecies( pSpecies );
Real speciesKd = m.getKDForSpecies( pSpecies );
\end{lstlisting}

Note that every configuration of libmoleculizer generates masses for
newly generated species, and so ''getMassForSpecies'' works under all
situations.  However, species radii and diffusion coefficients are
only generated when spatial extrapolation mode is configured by
calling the ''configureSpatialGenerationMode'' prior to loading the
model.  

\begin{lstlisting}[caption=Finding out information about species in
  non-spatial mode]
mzr::moculizer m;
m.enableNonSpatialReactionNetworkGeneration( false );
m.loadFile(''moleculizer-rules.xml'');

std::pair<std::string, const mzr::mzrSpecies*> speciesPair =
m.getSpeciesCatalog().first;

const mzr::mzrSpecies* pSpecies = speciesPair.second;

Real speciesMass = m.getKDForSpecies( pSpecies ); // ok

// This raises a BadModeXcpt exception, because this parameter is 
// not generated for this mode.
Real speciesRadius = m.getRadiusForSpecies( pSpecies ); 
\end{lstlisting}

Likewise, for determining parameters associated with the reaction,
functions ''



\subsubsection{The ReactionNetworkDescription interface.}
The ReactionNetworkDescription interface
(fnd::ReactionNetworkDescription<mzr::mzrSpecies, mzr::mzrReaction> in
code, found in src/fnd/reactionNetworkDescription.hh) manages questions
about species and reactions that have been created within a session of
libmoleculizer.  The basic, relevant functions to using this interface
are listed below.  Full a full description of this interface, please
consult class documentation provided elsewhere in this documentation.

Generally speaking, the ReactionNetworkDescription interaface can do
three things:

1.
Find species with certain names, using the findSpecies function.  This
function takes the name of a species and either returns a constant
pointer to that species, or throws a fnd::NoSuchSpeciesXcpt
exception.  Note that an exception may be thrown even if the species
name is a legal one for this model, so long as that species has not
been constructed yet.  Typically this is appropriate.  For instance,
any species formed as a procuct of a generated reaction is guaranteed
to have been created such that it will be returned by findSpecies.
That said, there may be special cases, such as working with data from
a previous run of the same model, where legal species names must be
used to create species even though the current expansion of the model
has not expanded that portion yet.  In this case,
mzr::moleculizer::getSpeciesWithName, as described in the previous
section, should be used.  

2.  Find reactions with one or more substrates.
This is accomplished using the findReactionWithSubstrates functions.
If unary reactions are desired (what decompositions can a particular
species undergo), use the function 
\lstinline@bool findReactionWithSubstrates(SpeciesCPtr A, std::vector<ReactionTypeCPtr>& reactionVector)@ function.  To use 
this, a species pointer that has been gotten using either the
findSpecies or getSpeciesWithName functions is passed, along with an
empty vector containing ReactionTypeCPtrs.  The function places a
unique pointer to every unary reaction involving that species as a
substrate, returning true if any exist.  

For instance:
m = mzr::molecuculizer();
m.attachFile( ``Simpledemo-rules.xml''); 

std::vector<const mzr::mzrReaction*> speciesDecompositionRxns;;

// This function also converts user names, described in the rules, to
// species pointers.
const mzr::mzrSpecies* species = m.getSpeciesWithName(``A-B-dimer'');

// When this function returns, speciesDecompositionRxns will contain
// one element, corresponding to the ``AB -> A + B'' reaction.  
m.findReactionWithSubstrates( species, speciesDecompositionRxns);

For reactions involving two substrates (libmoleculizer does not
support reactions involving three or greater substrates at this time),
the same idea is followed, except involving two species.  

Example:
\begin{lstlisting}
m = mzr::moleculizer();
m.attachFile(``Simpledemo-rules.xml'');
std::vector<const mzr::mzrReaction*> binaryRxns;;

const mzr::mzrSpecies* species1 = m.findSpecies(``___1A______'');
const mzr::mzrSpecies* species2 = m.findSpecies(``___1B______'');

// After this function call, binaryRxns will contain one element
// corresponding to the reaction ``A + B -> AB'').
m.findReactionWithSubstrates(species1, species2, binaryRxns);


ReactionNetworkDescriptionInterface also provides general information
on the state of the generated network through several functions:

unsigned int getTotalNumberSpecies() const, 
unsigned int getTotalNumberReactions() const,
bool checkSpeciesIsKnow( const std::string& speciesName) const.
\end{lstlisting}

These functions all provide information about the state of the
generated network.  The first two tell how large it is, and the third
helps determine what is and is not in it.  

Finally, there are other functions for manipulating and expanding the
reaction network.  Each species and reaction is of classtype
\lstinline@fnd::reactionNetworkComponent@, and had a function
\lstinline@expandReactionNetwork(unsigned int)@.  This function will expand the
reaction network around that object.  For any species X, calling this
function will create all new reactions X + Y -> Z, where Y is a species
already present in the system such that X and Y have a reaction rule
which applies to them and Z is the product, as determined by the
reaction rule.  Furthermore, any unary reactions X->? will be created
and recorded in the system.  Finally, all species that occur on the
right hand side of newly created reaction rules will be created and
added to the system.  This sort of expansion can be done in two ways.

1.  Calling \lstinline@expandReactionNetwork(unsigned int i)@ on a particular
reactionNetworkComponent.

All species \lstinline@mzr::mzrSpecies@ and reactions \lstinline@mzr::mzrReaction@ are
also of type \lstinline@fnd::reactionNeworkComponent@, and as such, have a function
called \lstinline@expandReactionNetwork(unsigned int i)@.  This function can only
be called once for any such reactionNeworkComponent (calling a second
time has no effect), but will expand the generated reaction network
around that component, generating new species and reactions.


2.  Calling
\lstinline@fnd::reactionNetowrkDescription::incrementNetworkBySpeciesName(const SpeciesID& name)@.  

Calling this function and giving it the name of a species already
recorded within the system has the same effect as calling
expandReactionNetwork on the mzr::mzrSpecies* returned by calling
fnd::ReactionnetoworkDescription::findSpecies using that same name. 

One the reaction network has been expanded, users may be interested to
find the difference with the old network: the set of species and
reactions that were generated in that step.  





\subsection{C Interface}
The c interface is an api written in the C programming languages
that exposes the libmoleculizer functionality to users of C.  Using
libmoleculizer with this interface is accomplished by including the
appropriate header file, called ``mzr/libmzr_c_interface.h''.
Functions performed using this interface can be grouped into
different types of operations.

, using
its creator method to create an object of type moleculizer, loading a
rules file into the object, using the other functions about the api to
work with that object, and finally using the api's functions to free
the object.  A simple example of how this is done is found in \ref{basiccinterex}.

\begin{ExampleC}[caption=Basic example using the c-interface, label=basiccinterex]
  int main(){
    char fileName[] = ``demos/omniKinase-rules.mzr'';
    
    moleculizer* the_moleculizer = createNewMoleculizerObject();
    loadRulesFile( the_moleculizer, fileName);

    /* Work with the moleculizer object here */

    freeMoleculizerObject( the_moleculizer );
    return 0;
    }
\end{ExampleC}

\subsubsection{Creating a moleculizer object}
In order to use libmoleculizer's species and rule based generation,
an instance of the fundamental data type - 'moleculizer' - of the
interface must be created.  This is done using the one and only
function of this interface, defined as ``moleculizer*
createNewMoleculizerObject()''.  When this function is called, it
returns a pointer to a newly created moleculizer object, which is
often called a handle.  This object is owned by the caller of the
function and \bf{must} be freed using the freeMoleculizerObject
function.

\subsubsection{Loading rules into a moleculizer object}
In order to perform reaction network generation, the moleculizer
object must be combined with a rules file.  To do this, either a rules
file, or a string containing the contents of a rules description must
be added to a moleculizer* object using either the ``int
loadRulesFile(moleculizer* handle, char* fileName)'', or the ``int
loadRulesString( moleculizer* handle, char* file)'' function
respectively.  An example for using a rules file was shown in
\ref{basiccinterex}.  If this rules file were laoded into a char*
elsewhere, it could be similarly used with the loadRulesString
function.

\subsubsection{Fundamental datatypes: reactions and species}
There are two types of datatypes besides the moleculizer handle that are used
in this interface: 'species' and 'reactions'.  These are the objects
passed around in the interface, and their definitions are shown below.

\begin{ExampleC}[caption=Fundamental data-type definitions,
  label=speciesreactiondef]

  typedef struct species_type
    {
      char* name; /* The canonical name of the chemical species */
      double* mass;  /* In daltons. */
      double* radius; /* In meters */ 
      double* diffusionCoeff; /* In ? */
    } species;
    
    typedef struct reaction_type
    {
        int numberReactants;
        species** reactantVector;
        
        int numberProducts;
        species** productVector;
        
        double* rate;
        
    } reaction;

\end{ExampleC}

These datatypes are typically returned by different functions of the
interface.  For instance, when requesting the single-substrate
reactions a species may be involved in, the result is an array of m
reaction*'s.  To easily free this datastructure, passing it to the
function ``void freeReactionArray( reaction** pRxnArray, unsigned int
numArrayElements)'' will free each of the reaction*'s in the array, as
well as the array itself.  Likewise the function ``void
freeSpeciesArray( species** pSpeciesArray, unsigned int
numArrayElements)'' will do the same to a species**, an array of
species*.  

If needed, functions for removing single reaction and species objects
are provided in the ``void freeReaction( reaction* pRxn )'' and ``void
freeSpecies( species* pSpecies )'' functions.  

\subsubsection{Looking up single substrate reactions}
For any complex species, users will want to know the different
decomposition reactions that species can undergo, as well as the
rate of each.  For any species, the set of all reactions such that
that species is the one and only reactant can be found using the ``int
getUnaryReactions(moleculizer* handle, char* speciesName, reaction***
ptrReactionPtrArray, int* numReactions)'' function.  An example of
it's use can be seen below.  

\begin{ExampleC}
  char speciesID[256] = ``___5alpha4Ste24Ste4___00121020______'';
  
  reaction** reactionArray;
  int numReactions;

  getUnaryReactions(handle, speciesID, &reactionArray, &numReactions);

  float totalPropensity = 0.0f;

  int iteration = 0;
  while(iteration != numReactions)
  {
    totalPropensity += reactionArray[iteration++];
  }

  freeReactionArray(reactionArray, numReactions);

\end{ExampleC}

\subsubsection{Looking up two substrate reactions}
Another common task is to determine whether or not two species can
react with one another.  This is the basic function used by a spatial
simulator, for isntance, which manages the positions and movement of
chemical species, but given that two species have collided, queries
libmoleculizer to determine what reactions, if any, those two species
can participate in together as well as the different propensities for
each reaction, represented as the intrinsic reaction rates of each
reaction.  

\subsubsection{Looking at global properties of the network}
There are four relevant functions involved in finding out the
information about the network as a whole.  The first two are the ``int
getNumberOfSpecies(moleculizer* hdl)'' and ``int
getNumberOfReactions(moleculiser* hdl)'' functions.  These will return
the total number of species and reactions in the reaction network of
the moleculizer object passed in.  Note that this is only the number
that has been generated at that point, not the number in the complete
reaction network.  To find out the complete size of the network, call
the expandNetwork function, in order to ensure that the entire network
has been generated.  

Next, all species and reactions can be read out, using either the
``int getAllSpecies(moleculizer* handle, species*** pSpeciesArray,
int* numberSpecies)'' or the ``int getAllReactions(moleculizer* handle,
reaction*** pSpeciesArray, int* numberSpecies)'' functions.  Their
usage is shown below.

\begin{ExampleC}
moleculizer* handle = createNewMoleculizerObject();
loadRulesFile(handle, some_rules_file);
expandNetwork(handle);

printf(``There are %d species and %d reactions in the entire
                   %network.\n", getNumberOfSpecies(handle),
                   %getNumberOfReactions(handle) );

species** speciesArray;
int numSpecies;

reaction** reactionArray;
int numReactions;

getAllSpecies(handle, &speciesArray, &numSpecies);
getAllReactions(handle, &speciesArray, &numSpecies);

if (numSpecies >= 1)
{
  printf(``The first species is %s and has approximate radius %f.", speciesArray[0]->name, speciesArray[0]->radius);
}

freeReactionArray(reactionArray, numReactions);
freeSpeciesArray(speciesArray, numSpecies);

freeMoleculizerObject(handle);

\end{ExampleC}

\subsubsection{User defined names}

In the explicit species section, users can describe complex species
and give them user defined names.  To find the corresponding canonical
id for a user defined species, needed for using the getReactionBetween
and getUnaryReactions functions, use the function ``int
convertUserNameToSpeciesKey(moleculizer* handle, char* theUserName, char*
correspondingSpeciesKey, int numberCharectorsSupplied)''.  Sample
usage is shown in \ref{userNameCEx}.

\begin{ExampleC}[caption=Example usage of convertUserNameToSpeciesKey,
  label=userNameCEx]

  char userName[] = ``alpha-ste2 dimer'';
  char canonicalName[256];
  
  int errorCode;

  convertUserNameToSpeciesKey( userName, canonicalName, 256);

  if (errorCode == 0) printf(``The canonical id of %s is %s", userName, canonicalName);
  if (errorCode == 1) printf(``No complex with the user-name '%s' was
                                %defined", userName);
  else if (errorCode == 2) printf(``The char* provided does not have
  enough memory to store the canonical id.'');

\end{ExampleC}

\subsubsection{Using species streams}
If a species stream is defined in the rules file, this can be looked
up using the function ``int getAllStreamSpecies(moleculizer* handle,
char* streamName, species** pSpeciesArray, int* numberSpecies)''. By
passing in the name of the species stream given in the rules, as well
as a pointer to a species** object.  

\begin{ExampleC}
moleculizer* the_mzr_obj = createNewMoleculizerObject();
loadRulesFule( the_mzr_obj, file_name );
expandNetwork( the_mzr_obj );

char streamName[256] = ``alpha-ste2 complex'';
char** speciesStreamArray;
int numberOfSpeciesInStream;

getAllStreamSpecies(the_mzr_obj, streamName, &speciesStreamArray,
&numberOfSpeciesInStream);

int index;
for( index = 0; index != numberOfSpeciesInStream; ++index)
{
  printf(``%s is a %s", speciesStreamArray[index]->name, streamName);
}

\end{ExampleC}

\subsection{Python Interface}








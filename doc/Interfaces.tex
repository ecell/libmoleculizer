\chapter{Libmoleculizer Interfaces}
\label{chap:interfacesChapter}

Libmoleculizer has multiple wrappings that allow users of different
languages -- currently either C++ or C -- to use rule-based reaction
network generation in their own programs.  This chapter describes
these interfaces and how to use them, and is followed by a section
discussing how to extend this procedure to new languages.

\section{The C++ Interface}
The C++ interface is the standard interface for libmoleculizer, as
well as the language that libmoleculizer has been implemented in.
Consequently, the C++ interface is the most powerful as well as the
most detailed. 

The C++ interface controls creating a libmoleculizer intance,
configuring it, loading a rules file into the instance, and expanding
the reaction network out.  The interface also allows inspecting the
network to see whether or not certain species have been created, see
what reactions might be possible for a set of products, as well as
several other capabilities.  These parts are given an overview below,
although for a completely thorough description of the API, please
consult either reference portions of this documentation, or browse the
source code (the moleculizer interface can be found in
src/mzr/moleculizer.hh and src/fnd/reactionNetworkDescription.hh).

\subsection{Overview}
Use of libmoleculizer will usually follow, a ''create, configure,
load, run'' pattern, with the first three parts being relatively
constant from time to time.  

\subsection{Creating a moleculizer instance}
To use libmoleculizer in C++ code, a moleculizer object, which
represents a single reaction-network that is expanded from a set of
reaction rules, must be created by the user. This is easy, as
moleculizer has exactly one constructor: moleculizer::moleculizer().
All uses of libmoleculizer to expand reaction-networks begin with the
creation of such an object.

\begin{ExampleCPP}[caption=Creating a moleculizer object, label=creatingmzrexample]
mzr::moleculizer m; // Note that this takes place in the namespace mzr,
                    // as does all the C++ interface.
\end{ExampleCPP}

\subsection{Configure}
Once a mzr::moleculizer instance has been created, parameters can be
configured to tell the moleculizer object how to expand the network.
As of now, there are two ways in which moleculizer can be configured.  

First, the generation depth can be set.  As discussed in a previous
chapter, species created by moleculizer are initially unexpanded.
What this means is that when a species is first created (a process
that can occur in three ways, either as part of the initial state and
loading of a set of rules, by explicit instructions from the user, or
as the product of a reaction created when some other species is
expanded) moleculizer does not automatically check that species
against all the other species to see if it can create new reactions
according to the rules.  Instead, the species remains in an unexpanded
state.  When that portion of the reaction network does need to be
generated, the species is expanded: moleculizer uses the rules against
this species as well as all other species in the model and uses them
to create new reactions.  These new reactions have products which may
themselves be new species.  If they are, they are added to the
moleculizer instance; whether these new product species are themselves
expanded at the time of their creation is determined by the generation
depth.  By setting the generation depth using the function
``moleculizer::setGenerateDepth(unsigned int)'', this property of
moleculizer's can be set.  The generation depth determines for how many
levels, or 'ply', will moleculizer expand species and reactions.  With
a value of 1, when a species is expanded (that's the 1), its products
are not expanded.  With a value of 2, the products are expanded, but
any new species that are created as a result of the 2nd expansion will
not be expanded, and so on.  The generation depth can be checked with
the function ``int moleculizer::getGenerationDepth() const''.  \bf{The
  default generation depth is 1.}

The second configuration parameter that can be set is whether
moleculizer should extrapolate reaction rates, as discussed
previously, for new reactions that it creates.  This must be set prior
to loading and initializing a set of rules; it will have no effect
once this is complete.  If its value is set to true, moleculizer will
use the reduced-mass proportionality constant model, as discussed in
chapter XXX, to modify the rates of newly created binary reactions.
This is done by taking $k_{rxn} = M^* * k_{rule}$, where $M^*$ is the
reduced-mass, $M^*=\sqrt{\over{m_{sub_1} * m_{sub_2}}{m_{sub_1} +
    m_{sub_2}} }$,  If it's value is set to false, moleculizer will
not extrapolate reaction rates, instead setting $k_{rxn} = k_{rule}$.
Read and write this property using the functions ``void
moleculizer::setRateExtrapolation( bool rateExtrapolation )'' and 
``bool moleculizer::getRateExtrapolation() const''.  \bf{By default
  this value is set to false.}  

\subsection{Loading}
Once configuration parameters have been set up as needed, a rules file
can be loaded.  This can be accomplished using one of three functions:
\lstinline@attachFileName( const std::string& aFileName )@.
\lstinline@attachString( const std::string& documentAsString )@, or
\lstinline@attachDocument( xmlpp::Document* pDoc )@.  Each of these
takes a model, in one form or another, loads it and parses it,
preparing Moleculizer for species and reaction generation.

A libmoleculizer model is an xml description of basic molecules (mols) and
reaction rules defined in terms of molecules, that usually describe
either protein-protein interactions or enzymatic reactions on
proteins.  A description of the full syntax of these files can be
found in the chapter 'Rules'.  An xml specification can be either
passed to libmoleculizer as a string containing file contents, a path
to a model file, or can be passed in as an xmlpp::Document*
(corresponding to an xml document parsed as a dom object using
libxml++, the xml library used by libmoleculizer).

Use cases:
1.  Model file is contained in a file.
If filePath is a string containing either an absolute or relative path
to the file, then the function moleculizer::attachFileName can be
called as follows.  

\begin{ExampleCPP}[caption=Loading a MZR file into a running
  moleculizer instance]
mzr::moleculizer m;
m.setGenerateDepth( 2 );  

// Load the file into the moleculizer object.
m.attachFileName( filePath );
\end{ExampleCPP}

2..Model is contained in a string.
If modelContents is a string containing a model file, then the
function moleculizer::attachString can be used to load this model file
as follows

\begin{ExampleCPP}[caption=Loading a MZR string into Moleculizer]
mzr::moleculizer m; 

m.setRateExtrapolation( true );

// Load the string holding the model file into the moleculizer object.
m.attachString( modelContents );
\end{ExampleCPP}

3.  Model has already been parsed and is contained in an
xmlpp::Document* object called ptrModelDoc.

\begin{ExampleCPP}[caption=Loading an XML document into moleculizer]
// Create a new reaction-network generator.
mzr::moleculizer m;

// Setup extrapolation here.
m.enableNonspatialReactionNetworkGeneration( false );  // For
instance.

// Load the Document* into moleculizer.
m.attachDocument( ptrModelDocument );
\end{ExampleCPP}

Any of these will load the necessary information into a model
instance. Note however, that information can only be added into
moleculizer once per instance.  Should the model have to be updated,
the moleculizer object must be destroyed and recreated and loaded with
the new model.  This is not optimal, and may change in upcoming
versions.  Users can determine whether a model is loaded by calling
the ''bool moleculizer::getModelHasBeenLoaded() const'' function.  

\subsection{Running}
Once a Moleculizer object has been created, configured, and a
rules-file has been loaded, there are several things that can be done.

The things that can be done are inspecting the species and reactions
that have been generated so far, expanding species and reactions in
order to generate additional portions of the species and reaction
network, inspecting the portion of the species and reaction network
that were created during the most recent expansion phase, and
searching for reactions that match certain parameters.  

The most basic operation that can be performed on a species and
reaction network is simply inspecting its contents.  These can be done
using the interface functions ''getSpeciesCatalog'' and
''getReactionList'' functions.  The 'getSpeciesCatalog' function
returns a map from std::string pointers to mzr::mzrSpecies*.  (Please
note that this map compares pointers based on their dereferenced
values rather than the pointer values themselves.)  By scanning
through this map, users can find out the identities of every species
that has been created, by using its unique identifier.  Using this
map, information can be gained for each species, using the relevant
'getKDForSpecies', 'getRadiusForSpecies', 'getMassForSpecies'
functions.  

\begin{ExampleCPP}[caption=Finding spatial properties of a species
  using moleculizer]
mzr::moculizer m;
m.enableSpatialReactionNetworkGeneration();
m.loadFile(''moleculizer-rules.xml'');

std::pair<std::string, const mzr::mzrSpecies*> speciesPair =
m.getSpeciesCatalog().first;

const mzr::mzrSpecies pSpecies = speciesPair.second;

Real speciesMass = m.getKDForSpecies( pSpecies );
Real speciesRadius = m.getRadiusForSpecies( pSpecies );
Real speciesKd = m.getKDForSpecies( pSpecies );
\end{ExampleCPP}

Note that every configuration of libmoleculizer generates masses for
newly generated species, and so ''getMassForSpecies'' works under all
situations.  However, species radii and diffusion coefficients are
only generated when spatial extrapolation mode is configured by
calling the ''configureSpatialGenerationMode'' prior to loading the
model.  

\begin{ExampleCPP}[caption=Finding out information about species in
  non-spatial mode]
mzr::moculizer m;
m.enableNonSpatialReactionNetworkGeneration( false );
m.loadFile(''moleculizer-rules.xml'');

std::pair<std::string, const mzr::mzrSpecies*> speciesPair =
m.getSpeciesCatalog().first;

const mzr::mzrSpecies* pSpecies = speciesPair.second;

Real speciesMass = m.getKDForSpecies( pSpecies ); // ok

// This raises a BadModeXcpt exception, because this parameter is 
// not generated for this mode.
Real speciesRadius = m.getRadiusForSpecies( pSpecies ); 
\end{ExampleCPP}

Likewise, for determining parameters associated with the reaction,
functions ''

\subsection{The ReactionNetworkDescription interface.}
The ReactionNetworkDescription interface
(fnd::ReactionNetworkDescription<mzr::mzrSpecies, mzr::mzrReaction> in
code, found in src/fnd/reactionNetworkDescription.hh) manages questions
about species and reactions that have been created within a session of
libmoleculizer.  The basic, relevant functions to using this interface
are listed below.  Full a full description of this interface, please
consult class documentation provided elsewhere in this documentation.

Generally speaking, the ReactionNetworkDescription interaface can do
three things:

1.
Find species with certain names, using the findSpecies function.  This
function takes the name of a species and either returns a constant
pointer to that species, or throws a fnd::NoSuchSpeciesXcpt
exception.  Note that an exception may be thrown even if the species
name is a legal one for this model, so long as that species has not
been constructed yet.  Typically this is appropriate.  For instance,
any species formed as a procuct of a generated reaction is guaranteed
to have been created such that it will be returned by findSpecies.
That said, there may be special cases, such as working with data from
a previous run of the same model, where legal species names must be
used to create species even though the current expansion of the model
has not expanded that portion yet.  In this case,
mzr::moleculizer::getSpeciesWithName, as described in the previous
section, should be used.  

2.  Find reactions with one or more substrates.
This is accomplished using the findReactionWithSubstrates functions.
If unary reactions are desired (what decompositions can a particular
species undergo), use the function 
\lstinline@bool findReactionWithSubstrates(SpeciesCPtr A, std::vector<ReactionTypeCPtr>& reactionVector)@ function.  To use 
this, a species pointer that has been gotten using either the
findSpecies or getSpeciesWithName functions is passed, along with an
empty vector containing ReactionTypeCPtrs.  The function places a
unique pointer to every unary reaction involving that species as a
substrate, returning true if any exist.  

For instance:
m = mzr::molecuculizer();
m.attachFile( ``Simpledemo-rules.xml''); 

std::vector<const mzr::mzrReaction*> speciesDecompositionRxns;;

// This function also converts user names, described in the rules, to
// species pointers.
const mzr::mzrSpecies* species = m.getSpeciesWithName(``A-B-dimer'');

// When this function returns, speciesDecompositionRxns will contain
// one element, corresponding to the ``AB -> A + B'' reaction.  
m.findReactionWithSubstrates( species, speciesDecompositionRxns);

For reactions involving two substrates (libmoleculizer does not
support reactions involving three or greater substrates at this time),
the same idea is followed, except involving two species.  

Example:
\begin{ExampleCPP}
m = mzr::moleculizer();
m.attachFile(``Simpledemo-rules.xml'');
std::vector<const mzr::mzrReaction*> binaryRxns;;

const mzr::mzrSpecies* species1 = m.findSpecies(``___1A______'');
const mzr::mzrSpecies* species2 = m.findSpecies(``___1B______'');

// After this function call, binaryRxns will contain one element
// corresponding to the reaction ``A + B -> AB'').
m.findReactionWithSubstrates(species1, species2, binaryRxns);


ReactionNetworkDescriptionInterface also provides general information
on the state of the generated network through several functions:

unsigned int getTotalNumberSpecies() const, 
unsigned int getTotalNumberReactions() const,
bool checkSpeciesIsKnow( const std::string& speciesName) const.
\end{ExampleCPP}

These functions all provide information about the state of the
generated network.  The first two tell how large it is, and the third
helps determine what is and is not in it.  

Finally, there are other functions for manipulating and expanding the
reaction network.  Each species and reaction is of classtype
\lstinline@fnd::reactionNetworkComponent@, and had a function
\lstinline@expandReactionNetwork(unsigned int)@.  This function will expand the
reaction network around that object.  For any species X, calling this
function will create all new reactions X + Y -> Z, where Y is a species
already present in the system such that X and Y have a reaction rule
which applies to them and Z is the product, as determined by the
reaction rule.  Furthermore, any unary reactions X->? will be created
and recorded in the system.  Finally, all species that occur on the
right hand side of newly created reaction rules will be created and
added to the system.  This sort of expansion can be done in two ways.

1.  Calling \lstinline@expandReactionNetwork(unsigned int i)@ on a particular
reactionNetworkComponent.

All species \lstinline@mzr::mzrSpecies@ and reactions \lstinline@mzr::mzrReaction@ are
also of type \lstinline@fnd::reactionNeworkComponent@, and as such, have a function
called \lstinline@expandReactionNetwork(unsigned int i)@.  This function can only
be called once for any such reactionNeworkComponent (calling a second
time has no effect), but will expand the generated reaction network
around that component, generating new species and reactions.


2.  Calling
\lstinline@fnd::reactionNetowrkDescription::incrementNetworkBySpeciesName(const SpeciesID& name)@.  

Calling this function and giving it the name of a species already
recorded within the system has the same effect as calling
expandReactionNetwork on the mzr::mzrSpecies* returned by calling
fnd::ReactionNetworkDescription::findSpecies using that same name. 

One the reaction network has been expanded, users may be interested to
find the difference with the old network: the set of species and
reactions that were generated in that step.  


\section{C Interface}
The c interface is an api for libmoleculizer written in the C
programming languages.  Using libmoleculizer with this interface is
accomplished by including the appropriate header file, called
``mzr/libmzr\_c\_interface.h''. 

Generally speaking, using this interface consists of creating a new
moleculizer* object by calling the createNewMoleculizerObject()
function, attaching rules to that object by calling the
loadRulesFile(moleculizer*, char* fileName) function, using the
various functions in the api to expand, get information about, and
work with the represented network, and finally releasing the memory by
calling the freeMoleculizerObject(moleculizer*) function.  

\begin{ExampleC}[caption=Basic example using the c-interface]
  int main(){
    char fileName[] = ``demos/omniKinase-rules.mzr'';
    
    moleculizer* the_moleculizer = createNewMoleculizerObject();
    loadRulesFile( the_moleculizer, fileName);

    /* Work with the moleculizer object here */

    freeMoleculizerObject( the_moleculizer );
    return 0;
    }
\end{ExampleC}

\subsection{Creating a moleculizer object}
In order to use libmoleculizer's species and rule based generation,
an instance of the fundamental data type - 'moleculizer' - of the
interface must be created.  This is done using the one and only
function of this interface, defined as ``moleculizer*
createNewMoleculizerObject()''.  When this function is called, it
returns a pointer to a newly created moleculizer object, which is
often called a handle.  This object is owned by the caller of the
function and \bf{must} be freed using the freeMoleculizerObject
function.

\subsection{Loading rules into a moleculizer object}
In order to perform reaction network generation, the moleculizer
object must be combined with a rules file.  To do this, either a rules
file, or a string containing the contents of a rules description must
be added to a moleculizer* object using either the ``int
loadRulesFile(moleculizer* handle, char* fileName)'', or the ``int
loadRulesString( moleculizer* handle, char* fileAsString)'' function
respectively.  

\subsection{Fundamental datatypes: reactions and species}
There are two types of datatypes besides the moleculizer handle that are used
in this interface: 'species' and 'reactions'.  These are the objects
passed around in the interface, and their definitions are shown below.

\begin{ExampleC}[caption=Fundamental data-type definitions,
  label=speciesreactiondef]

  typedef struct species_type
    {
      char* name; /* The canonical name of the chemical species */
      double* mass;  /* In daltons. */
      double* radius; /* In meters */ 
      double* diffusionCoeff; /* In ? */
    } species;
    
    typedef struct reaction_type
    {
        int numberReactants;
        species** reactantVector;
        
        int numberProducts;
        species** productVector;
        
        double* rate;
        
    } reaction;

\end{ExampleC}

These datatypes are returned by different functions in the interface.
For instance, when requesting the set of single-substrate reactions a
species may be involved in, the result is an array of reaction*'s.
When use of this array (or arrays of species*'s) is finished, its
memory should be realeased.  This can easily be done by passing it to
the function ``void freeReactionArray( reaction** pRxnArray, unsigned
int numArrayElements)'', which will free each of the reaction*'s in the
array, as well as the array itself.  Likewise the function ``void
freeSpeciesArray( species** pSpeciesArray, unsigned int
numArrayElements)'' will do the same to an array of species*.

If needed, functions for removing single reaction and species objects
are provided in the ``void freeReaction( reaction* pRxn )'' and ``void
freeSpecies( species* pSpecies )'' functions.

\subsection{Looking up single substrate reactions}
For any complex species, users will want to know the different
decomposition reactions that species can undergo, as well as the rate
of each of them.  For any species, the set of all reactions such that
that species is the one and only reactant can be found using the ``int
getUnaryReactions(moleculizer* handle, char* speciesName, reaction***
ptrReactionPtrArray, int* numReactions)'' function.  An example of
it's use can be seen below.

\begin{ExampleC}
  char speciesID[256] = ``___5alpha4Ste24Ste4___00121020______'';
  
  reaction** reactionArray;
  int numReactions;

  getUnaryReactions(handle, speciesID, &reactionArray, &numReactions);

  float totalPropensity = 0.0f;

  int iteration = 0;
  while(iteration != numReactions)
  {
    totalPropensity += reactionArray[iteration++];
  }

  freeReactionArray(reactionArray, numReactions);

\end{ExampleC}

\subsection{Looking up two substrate reactions}
Another common task is to determine whether or not two species can
react with one another.  This is the basic function used by a spatial
simulator, for instance, which manages the positions and movement of
chemical species, but given that two species have collided, queries
libmoleculizer to determine what reactions, if any, those two species
can participate in together as well as the different propensities for
each reaction, represented as the intrinsic reaction rates of each
reaction.  

\begin{ExampleC}
  char speciesID1[256] = ``___4Ste24Ste4___0012______'';
  char speciesID2[256] = ``___5alpha______'';
  
  reaction** reactionArray;
  int numReactions;

  getReactionsBetween(handle, speciesID1, speciesID2, &reactionArray, &numReactions);

  float totalPropensity = 0.0f;

  int iteration = 0;
  while(iteration != numReactions)
  {
    totalPropensity += reactionArray[iteration++];
  }

  freeReactionArray(reactionArray, numReactions);

\end{ExampleC}

\subsection{Finding all reactions a species participates in}
On occasion, and typically when investigating the structural
properties of the network, rather than in the course of simulation,
the set of all reactions where a particular species participates as a
substrate (both unary and binary) may be desired.  This can be done
using the function ``int getReactionsInvolving(moleculizer* handle,
char* speciesName, reaction*** ptrReactionPtrArray, int*
numReactions)''.  

\begin{ExampleC}
  /* Find the species involved in the most reactions */

  expandNetwork( handle );

  species** speciesArray;
  int numSpecies;
  getAllSpecies(handle, &speciesArray, &numSpecies);
  

  int mostReactions = -1;
  int speciesNdx;

  char tagBuffer[10];

  for(speciesNdx = 0; speciesNdx != numSpecies; ++speciesNdx)
  {
    reaction** reactionArray;
    int numReactions;

    getReactionsInvolving(handle, speciesArray[speciesNdx]->name, &reactionArray, &numReactions);
    
    if (numReactions > mostReactions)
    {
      mostReactions = numReactions;
      convertIDToTag( handle, speciesArray[speciesNdx]->name, tagBuffer, 10);
    }

  }

  char name[1000];
  convertTagToID( handle, tagBuffer, name, 1000);

  printf(``Species s has greatest connectivity of d'', name, numReactions);

\end{ExampleC}

\subsection{Looking at global properties of the network}
There are four relevant functions involved in finding out the
information about the network as a whole.  The first two are the ``int
getNumberOfSpecies(moleculizer* hdl)'' and ``int
getNumberOfReactions(moleculiser* hdl)'' functions.  These will return
the total number of species and reactions in the reaction network of
the moleculizer object passed in.  Note that this is only the number
that has been generated at that point, not the number in the complete
reaction network.  To find out the complete size of the network, call
the expandNetwork function, in order to ensure that the entire network
has been generated.  

Next, all species and reactions can be read out, using either the
``int getAllSpecies(moleculizer* handle, species*** pSpeciesArray,
int* numberSpecies)'' or the ``int getAllReactions(moleculizer* handle,
reaction*** pSpeciesArray, int* numberSpecies)'' functions.  Their
usage is shown below.

\begin{ExampleC}
moleculizer* handle = createNewMoleculizerObject();
loadRulesFile(handle, some_rules_file);
expandNetwork(handle);

printf(``There are d species and d reactions in the entire
                   network.\n'', getNumberOfSpecies(handle),
                   getNumberOfReactions(handle) ); 

species** speciesArray;
int numSpecies;

reaction** reactionArray;
int numReactions;

getAllSpecies(handle, &speciesArray, &numSpecies);
getAllReactions(handle, &speciesArray, &numSpecies);

if (numSpecies >= 1)
{
  printf(``The first species is s and has approximate radius f.'', speciesArray[0]->name, speciesArray[0]->radius);
}

freeReactionArray(reactionArray, numReactions);
freeSpeciesArray(speciesArray, numSpecies);

freeMoleculizerObject(handle);

\end{ExampleC}

\subsection{Working with Names}

\subsubsection{Tags, canonical ids, and user names}

Libmoleculizer has multiple mechanisms for identifying species:
user-names, tags, canonical ids.  User-names for species are defined
in the mzr file.  In the explicit-species section, users can define
any number of arbitrary complex species and give them arbitrary
names.  Both tags and canonical ids are automatically generated, and
both help uniquely identify complex species, however there are several
key differences.  Tags are short, usually 8 charecters long, and
uniquely identify species within a single libmoleculizer instance.
That is, within a particular libmoleculizer instance, two complex
species are the same if and only if they have the same tag.  However,
tags cannot be compared between instances.  Different species may be
given the same tag and identical species may be given different tags
across program instance boundries.  Furthermore, although tags may be
looked up, species cannot be constructed using its tag.  In contrast,
to each complex species a canonical id is also generated.  The
advantage of the canonical id is twofold.  First, canonical ids
uniquely identify complexes between different instances of
libmoleculizer.  Two species are identical if and only if their
canonical ids are identical, even when the species and ids have been
generated by different instances of libmoleculizer (this is system
independent as well).  Secondly, species can be recreated based on the
canonical id.  If a canonical id is serialized, the corresponding
species can be recreated in any future instance of libmoleculizer
(including, again, across different systems).  The disadvantage of
canonical ids is their potentially large size.  Canonical IDs have
potentially unbounded size, and typically have length that is
proportional to the number of molecules in the complex -- complexes
IDs with length of 750 charectors or greater are not uncommon.

Each of these names has their place.  User-names are typically used to
refer to complicated species is a human-readable way; tags can be used
for tracking species within a running simulation; canonical IDs are
usually used for input/output capabilities.  The remainder of this
section discusses how to work with each type of name, specifically,
how to get the species corresponding to a particular name or tag, and
how to convert between different types of names (finding the
corresponding canonical ID for a particular tag for instance).

\subsubsection{Converting between tags and ids}
Converting between tags and canonical IDs is a very straighforward
procedure.  Depending on which direction conversion is desired, use
either the ``int convertTagToID( moleculizer* handle, char*
speciesTag, char* speciesID, int idSize)'' or the ``int
convertIDToTag( moleculizer* handle, char* speciesID, char*
speciesTag, int tagSize)'' functions.  In both these function, the
first char* parameter takes the name (either the tag or ID) that the
user is converting from.  The second char* parameter is a charector
buffer where the converted name should be put.  The final parameter
takes the size of the destination buffer.  Both these functions return
0 on success and non-zero on failure.  

\begin{ExampleC}

char originalTagName[] = ``0x0384a4'';

char canonicalID[1000];
char newTag[10];

if (convertTagToID( handle, originalTagName, canonicalID, 1000)) printErrorAndQuit();
if (convertIDToTag(handle, canonicalID, newTag, 10)) printErrorAndQuit();

/* This will always succeed.  If it doesn't, send me a bug report! */
assert( !strcmp( origicalTagName, newTag) );

\end{ExampleC}

\subsubsection{User defined names}

In the explicit species section, users can describe complex species
and give them user defined names.  To find either the corresponding
tag or the canonical id for a user defined species, needed for using
the getReactionBetween and getUnaryReactions functions, use either the
functions ``int convertUserNameToSpeciesID(moleculizer* handle, char*
theUserName, char* correspondingSpeciesID, int bufferSize)'' or ``int
convertUserNameToSpeciesID(moleculizer* handle, char* theUserName,
char* correspondingTag, int bufferSize)''. 

\begin{ExampleC}[caption=Example usage of convertUserNameToSpeciesID,
  label=userNameCEx]

  char userName[] = ``alpha-ste2 dimer'';
  char canonicalName[256];
  
  int errorCode;

  convertUserNameToSpeciesID( userName, canonicalName, 256);

  if (errorCode == 0) printf(``The canonical id of %s is %s", userName, canonicalName);
  if (errorCode == 1) printf(``No complex with the user-name '%s' was
                                %defined", userName);
  else if (errorCode == 2) printf(``The char* provided does not have
  enough memory to store the canonical id.'');

\end{ExampleC}

\subsection{Using species streams}
If a species stream is defined in the rules file, this can be looked
up using the function ``int getAllStreamSpecies(moleculizer* handle,
char* streamName, species** pSpeciesArray, int* numberSpecies)''. By
passing in the name of the species stream given in the rules, as well
as a pointer to a species** object.  

\begin{ExampleC}
moleculizer* the_mzr_obj = createNewMoleculizerObject();
loadRulesFule( the_mzr_obj, file_name );
expandNetwork( the_mzr_obj );

char streamName[256] = ``alpha-ste2 complex'';
char** speciesStreamArray;
int numberOfSpeciesInStream;

getAllStreamSpecies(the_mzr_obj, streamName, &speciesStreamArray,
&numberOfSpeciesInStream);

int index;
for( index = 0; index != numberOfSpeciesInStream; ++index)
{
  printf(``s is a s'', speciesStreamArray[index]->name, streamName);
}

\end{ExampleC}

\subsection{Expanding Individual Species}
Many times users will want to expand the reaction network around a
particular species.  What this means is to apply the rules to that
species, generating each of the unary reactions that species can
participate in, as well as generating all the binary reactions that
species can participate in with each already expanded species in the
reaction network.  This can be done either by using the species ID,
the tag, or a pointer to the species itself using any of the functions
``int expandSpeciesByTag( moleculizer* handle, char* theTag)'', ``int
expandSpeciesByID( moleculizer* handle, char* theID)'', or ``int
expandSpecies( moleculizer* handle, species* mzrSpecies)''.

\begin{ExampleC}

char userName[] = ``alpha-ste2 complex'';
char tag[10];

if( convertUserNameToSpeciesTag(handle, userName, tag, 10) ) printErrorAndQuit();

expandSpeciesByTag( handle, tag);

\end{ExampleC}

\subsection{Expanding Individual Reactions}
In addition to expanding individual species, with a reaction* a user
may expand that reaction, which has the same effect as expanding each
of that reaction's products.  This is done using the function ``int
expandReaction(moleculizer* handle, reaction* mzrReaction)''. 

\begin{ExampleC}
  char userName[] = ``alpha-ste2 complex'';

  char speciesID[1000];
  if(convertUserNameToSpeciesID( handle, userName, speciesID, 1000) ) 
  { 
    printErrorAndQuit();
  }

  reaction** reactionArray;
  int numDecompositionRxns;

  getUnaryReactions(handle, speciesID, &reactionArray, &numDecompositionRxns);

  if (numDecompositionRxns > 0)
  {
    expandReaction(handle, reactionArray[0] );
  }
  

\end{ExampleC}










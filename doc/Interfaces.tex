\chapter{Libmoleculizer Interfaces}
\label{chap:interfacesChapter}

Libmoleculizer is primarily a library.  It expeses its capabilities
using different language interfaces (currently C++ and C) that allow
users of different languages.  This chapter describes these
interfaces and how to use them.

\section{The C++ Interface}
The C++ interface is the standard interface for libmoleculizer, as
well as the implementation language for libmoleculizer.  Consequently,
the C++ interface is the most powerful as well as the most detailed.

The C++ interface controls creating a libmoleculizer instance,
configuring it, loading a rules file into the instance, and expanding
the reaction network out.  The interface also allows inspecting the
network to see whether or not certain species have been created, see
what reactions might be possible for a set of products, as well as
several other capabilities.  

These parts are given an overview below, although for a completely
thorough description of the API, please consult either reference
portions of this documentation, or browse the source code (the
moleculizer interface can be found in src/mzr/moleculizer.hh and
src/fnd/reactionNetworkDescription.hh).

\subsection{Overview}
Use of libmoleculizer in client code will usually follow, a ''create a
libmoleculizer instance, configure the instance, load a file, run
libmoleculizer, and read out species and reactions'' pattern.  

\subsection{Creating a moleculizer instance}
To use libmoleculizer in C++ code, a moleculizer object, which
represents a single reaction-network that is expanded from a set of
reaction rules, must be created by the user. This is easy, as
moleculizer has exactly one constructor: moleculizer::moleculizer().
All uses of libmoleculizer to expand reaction-networks begin with the
creation of such an object.  To create a moleculizer object import
``mzr/moleculizer.hh''  into your code and call the default
constructor, as in the following example.  

\begin{ExampleCPP}[caption=Creating a moleculizer object, label=creatingmzrexample]
mzr::moleculizer m; // Note that this takes place in the namespace mzr,
                    // as does all the C++ interface.
\end{ExampleCPP}


\subsection{Configure}
Once a mzr::moleculizer instance has been created, parameters can be
configured to tell the moleculizer object how to expand the network.
As of now, there are two ways in which moleculizer can be configured.  

First, the generation depth can be set (although it begins with a
default of 1) by calling the moleculizer member fuction
``moleculizer::setGenerateDepth(unsigned int)''.  The generation depth
controlls how much generation of species and reaction are done when
any species is expanded.  

By default all new species that exist in libmoleculizer are
unexpanded.  By expanding a species, all reactions that can occur
between that newly expanding species and all species that have been
previously expanded are generated.  These reactions are all added to
libmoleculizer, and if any of those reactions' products are new
species, those new species are added to libmoleculizer.  If the
generation depth is 1, generation stops here.  If it is 2, all newly
generated species are expanded and the new species generated during
that phase are added in as unexpanded and generation stops.  If it is
3, those species are expanded and so on.  

The second configuration parameter that can be set is whether
moleculizer should extrapolate reaction rates for new reactions that
it creates, using the function ``moleculizer::setRateExtrapolation(
bool )''.  If reaction rate extrapolation is turned off -- which is the default
-- the rate used for the final reaction is simply the same number that
was provided.  Using reaction-rate extrapolation will modify the basic
rate by taking $k_{rxn} = M^*
* k_{rule}$, where $M^*$ is the reduced-mass,
$M^*=\sqrt{\frac{m_{sub_1} * m_{sub_2}}{m_{sub_1} + m_{sub_2}} }$.

\subsection{Loading a Rule fils}
Once a moleculizer object has been created and configured, it must be
given a rules file to load.  There are two options here.  The first
option is to load in a standard MZR rules file; the second option is
to load an xml rules file.  Either can be passed in as either a file
name or as a string containing the file contents.  Only one file can
be loaded per instance of libmoleculizer.

To load a MZR rules file, call either of the member functions
``moleculizer::loadCommonRulesFileName( const std::string&)'' or
``moleculizer::loadCommonRulesFile( const std::string&)''.  Pass a
file name to the first one, and a copy of the file in text format to
the other.

Loading a MZR rules file in the preceeding manner causes a python
module to be loaded that compiles the MZR file to XML format.  If for
whatever reason you have the XML file intermediates, these can be
loaded directly as well, using the member functions
``moleculizer.loadXmlFileName(const std::string&)'' or
``moleculizer.loadXmlFile(const std::string&)''.  

Any of these will load the necessary information into a model
instance. Note however, that information can only be added into
moleculizer once per instance.  Should the model have to be updated,
the moleculizer object must be destroyed and recreated and loaded with
the new model.  This is not optimal, and may change in upcoming
versions.  

Users can determine whether a model has been loaded by calling
the ''bool moleculizer::getModelHasBeenLoaded() const'' function.  


 \subsection{Running}
Once a Moleculizer object has been created, configured, and a
rules-file has been loaded, there are several things that can be done.

The things that can be done are inspecting the species and reactions
that have been generated so far, expanding species and reactions in
order to generate additional portions of the species and reaction
network, inspecting the portion of the species and reaction network
that were created during the most recent expansion phase, and
searching for species and reactions match certain properties.  

The most basic operation that can be performed on a species and
reaction network is simply inspecting its contents.  These can be done
using the interface functions ''getSpeciesCatalog'' and
''getReactionList'' functions.  The 'getSpeciesCatalog' function

returns a map<std::string*, mzr::mzrSpecies*>.  (Please
note that this map compares pointers based on their dereferenced
values rather than the pointer values themselves.)  By scanning
through this map, users can find out the identities of every species
that has been created, organized by tagged name.  

Using this map, information can be obtained for each species, using the
relevant 'getKDForSpecies', 'getRadiusForSpecies', 'getMassForSpecies'
functions.


generateCompleteNetwork()
generateCompleteNetwork(long maxNumSpecies, long maxNumRxns = -1);
getUserNames
recordUserNameToSpeciesIDPair
nameIsUserName

convertSomeNameToTaggedName
getSpeciesWithSomeName

getSpeciesWIthTaggedName (const/non-const)
getSpeciesWithUniqueID()
convertUserNameToSpeciesID
convertUserNameToTaggedName


        int getNumberOfDefinedModifications() const;
        int getNumberOfDefinedMols() const;
        int getNumberOfDefinedRules() const;

        int getNumberOfDimerReactionRules() const;
        int getNumberOfOmniGenReactionRules() const;
        int getNumberOfUniMolReactionRules() const;
        int getNumberOfReactionRules() const;

        int getNumberOfPlexFamilies() const;


        void getSpeciesStreams( std::vector<std::string>& speciesStreamNames) const;
        int getNumberOfSpeciesStreams() const;
        int getNumberOfSpeciesInSpeciesStream(const std::string& streamName) const;
        void getSpeciesInSpeciesStream(const std::string& streamName, std::vector<const mzr::mzrSpecies*>& speciesVector) const;

        bool speciesWithTagIsInSpeciesStream(const std::string speciesTag, const std::string& speciesStream ) const;
        bool speciesWithUniqueIDIsInSpeciesStream(const std::string
        speciesTag, const std::string& speciesStream ) const;



        findReactionWithSubstrates
        getTotalNumberSpecies
        getTotalNumberReactions





 
\subsection{The ReactionNetworkDescription interface.}
The ReactionNetworkDescription interface
(fnd::ReactionNetworkDescription<mzr::mzrSpecies, mzr::mzrReaction> in
code, found in src/fnd/reactionNetworkDescription.hh) manages questions
about species and reactions that have been created within a session of
libmoleculizer.  The basic, relevant functions to using this interface
are listed below.  Full a full description of this interface, please
consult class documentation provided elsewhere in this documentation.

Generally speaking, the ReactionNetworkDescription interaface can do
three things:

1.
Find species with certain names, using the findSpecies function.  This
function takes the name of a species and either returns a constant
pointer to that species, or throws a fnd::NoSuchSpeciesXcpt
exception.  Note that an exception may be thrown even if the species
name is a legal one for this model, so long as that species has not
been constructed yet.  Typically this is appropriate.  For instance,
any species formed as a procuct of a generated reaction is guaranteed
to have been created such that it will be returned by findSpecies.
That said, there may be special cases, such as working with data from
a previous run of the same model, where legal species names must be
used to create species even though the current expansion of the model
has not expanded that portion yet.  In this case,
mzr::moleculizer::getSpeciesWithName, as described in the previous
section, should be used.  

2.  Find reactions with one or more substrates.
This is accomplished using the findReactionWithSubstrates functions.
If unary reactions are desired (what decompositions can a particular
species undergo), use the function 
\lstinline@bool findReactionWithSubstrates(SpeciesCPtr A, std::vector<ReactionTypeCPtr>& reactionVector)@ function.  To use 
this, a species pointer that has been gotten using either the
findSpecies or getSpeciesWithName functions is passed, along with an
empty vector containing ReactionTypeCPtrs.  The function places a
unique pointer to every unary reaction involving that species as a
substrate, returning true if any exist.  

For instance:
\begin{ExampleCPP}
m = mzr::molecuculizer();
m.attachFile( ``Simpledemo-rules.xml''); 

std::vector<const mzr::mzrReaction*> speciesDecompositionRxns;;

// This function also converts user names, described in the rules, to
// species pointers.
const mzr::mzrSpecies* species = m.getSpeciesWithName(``A-B-dimer'');

// When this function returns, speciesDecompositionRxns will contain
// one element, corresponding to the ``AB -> A + B'' reaction.  
m.findReactionWithSubstrates( species, speciesDecompositionRxns);
\end{ExampleCPP}

For reactions involving two substrates (libmoleculizer does not
support reactions involving three or greater substrates at this time),
the same idea is followed, except involving two species.  

Example:
\begin{ExampleCPP}
m = mzr::moleculizer();
m.attachFile(``Simpledemo-rules.xml'');
std::vector<const mzr::mzrReaction*> binaryRxns;;

const mzr::mzrSpecies* species1 = m.findSpecies(``___1A______'');
const mzr::mzrSpecies* species2 = m.findSpecies(``___1B______'');

// After this function call, binaryRxns will contain one element
// corresponding to the reaction ``A + B -> AB'').
m.findReactionWithSubstrates(species1, species2, binaryRxns);


ReactionNetworkDescriptionInterface also provides general information
on the state of the generated network through several functions:

unsigned int getTotalNumberSpecies() const, 
unsigned int getTotalNumberReactions() const,
bool checkSpeciesIsKnow( const std::string& speciesName) const.
\end{ExampleCPP}

These functions all provide information about the state of the
generated network.  The first two tell how large it is, and the third
helps determine what is and is not in it.  

Finally, there are other functions for manipulating and expanding the
reaction network.  Each species and reaction is of classtype
\lstinline@fnd::reactionNetworkComponent@, and had a function
\lstinline@expandReactionNetwork(unsigned int)@.  This function will expand the
reaction network around that object.  For any species X, calling this
function will create all new reactions X + Y -> Z, where Y is a species
already present in the system such that X and Y have a reaction rule
which applies to them and Z is the product, as determined by the
reaction rule.  Furthermore, any unary reactions X->? will be created
and recorded in the system.  Finally, all species that occur on the
right hand side of newly created reaction rules will be created and
added to the system.  This sort of expansion can be done in two ways.

1.  Calling \lstinline@expandReactionNetwork(unsigned int i)@ on a particular
reactionNetworkComponent.

All species \lstinline@mzr::mzrSpecies@ and reactions \lstinline@mzr::mzrReaction@ are
also of type \lstinline@fnd::reactionNeworkComponent@, and as such, have a function
called \lstinline@expandReactionNetwork(unsigned int i)@.  This function can only
be called once for any such reactionNeworkComponent (calling a second
time has no effect), but will expand the generated reaction network
around that component, generating new species and reactions.


2.  Calling
\lstinline@fnd::reactionNetowrkDescription::incrementNetworkBySpeciesName(const SpeciesID& name)@.  

Calling this function and giving it the name of a species already
recorded within the system has the same effect as calling
expandReactionNetwork on the mzr::mzrSpecies* returned by calling
fnd::ReactionNetworkDescription::findSpecies using that same name. 

One the reaction network has been expanded, users may be interested to
find the difference with the old network: the set of species and
reactions that were generated in that step.  


\section{C Interface}
The c interface is an api for libmoleculizer written in the C
programming languages.  Using libmoleculizer with this interface is
accomplished by including the appropriate header file, called
``mzr/libmzr\_c\_interface.h''. 

Generally speaking, using this interface consists of creating a new
moleculizer* object by calling the createNewMoleculizerObject()
function, attaching rules to that object by calling the
loadRulesFile(moleculizer*, char* fileName) function, using the
various functions in the api to expand, get information about, and
work with the represented network, and finally releasing the memory by
calling the freeMoleculizerObject(moleculizer*) function.  

\begin{ExampleC}[caption=Basic example using the c-interface]
  int main(){
    char fileName[] = ``demos/omniKinase-rules.mzr'';
    
    moleculizer* the_moleculizer = createNewMoleculizerObject();
    loadRulesFile( the_moleculizer, fileName);

    /* Work with the moleculizer object here */

    freeMoleculizerObject( the_moleculizer );
    return 0;
    }
\end{ExampleC}

\subsection{Creating a moleculizer object}
In order to use libmoleculizer's species and rule based generation,
an instance of the fundamental data type - 'moleculizer' - of the
interface must be created.  This is done using the one and only
function of this interface, defined as ``moleculizer*
createNewMoleculizerObject()''.  When this function is called, it
returns a pointer to a newly created moleculizer object, which is
often called a handle.  This object is owned by the caller of the
function and {\bf must} be freed using the freeMoleculizerObject
function.

\subsection{Loading rules into a moleculizer object}
In order to perform reaction network generation, the moleculizer
object must be combined with a rules file.  To do this, either a rules
file, or a string containing the contents of a rules description must
be added to a moleculizer* object using either the ``int
loadRulesFile(moleculizer* handle, char* fileName)'', or the ``int
loadRulesString( moleculizer* handle, char* fileAsString)'' function
respectively.  

\subsection{Fundamental datatypes: reactions and species}
There are two types of datatypes besides the moleculizer handle that are used
in this interface: 'species' and 'reactions'.  These are the objects
passed around in the interface, and their definitions are shown below.

\begin{ExampleC}[caption=Fundamental data-type definitions,
  label=speciesreactiondef]

  typedef struct species_type
    {
      char* name; /* The canonical name of the chemical species */
      double* mass;  /* In daltons. */
      double* radius; /* In meters */ 
      double* diffusionCoeff; /* In ? */
    } species;
    
    typedef struct reaction_type
    {
        int numberReactants;
        species** reactantVector;
        
        int numberProducts;
        species** productVector;
        
        double* rate;
        
    } reaction;

\end{ExampleC}

These datatypes are returned by different functions in the interface.
For instance, when requesting the set of single-substrate reactions a
species may be involved in, the result is an array of reaction*'s.
When use of this array (or arrays of species*'s) is finished, its
memory should be realeased.  This can easily be done by passing it to
the function ``void freeReactionArray( reaction** pRxnArray, unsigned
int numArrayElements)'', which will free each of the reaction*'s in the
array, as well as the array itself.  Likewise the function ``void
freeSpeciesArray( species** pSpeciesArray, unsigned int
numArrayElements)'' will do the same to an array of species*.

If needed, functions for removing single reaction and species objects
are provided in the ``void freeReaction( reaction* pRxn )'' and ``void
freeSpecies( species* pSpecies )'' functions.

\subsection{Looking up single substrate reactions}
For any complex species, users will want to know the different
decomposition reactions that species can undergo, as well as the rate
of each of them.  For any species, the set of all reactions such that
that species is the one and only reactant can be found using the ``int
getUnaryReactions(moleculizer* handle, char* speciesName, reaction***
ptrReactionPtrArray, int* numReactions)'' function.  An example of
it's use can be seen below.

\begin{ExampleC}
  char speciesID[256] = ``___5alpha4Ste24Ste4___00121020______'';
  
  reaction** reactionArray;
  int numReactions;

  getUnaryReactions(handle, speciesID, &reactionArray, &numReactions);

  float totalPropensity = 0.0f;

  int iteration = 0;
  while(iteration != numReactions)
  {
    totalPropensity += reactionArray[iteration++];
  }

  freeReactionArray(reactionArray, numReactions);

\end{ExampleC}

\subsection{Looking up two substrate reactions}
Another common task is to determine whether or not two species can
react with one another.  This is the basic function used by a spatial
simulator, for instance, which manages the positions and movement of
chemical species, but given that two species have collided, queries
libmoleculizer to determine what reactions, if any, those two species
can participate in together as well as the different propensities for
each reaction, represented as the intrinsic reaction rates of each
reaction.  

\begin{ExampleC}
  char speciesID1[256] = ``___4Ste24Ste4___0012______'';
  char speciesID2[256] = ``___5alpha______'';
  
  reaction** reactionArray;
  int numReactions;

  getReactionsBetween(handle, speciesID1, speciesID2, &reactionArray, &numReactions);

  float totalPropensity = 0.0f;

  int iteration = 0;
  while(iteration != numReactions)
  {
    totalPropensity += reactionArray[iteration++];
  }

  freeReactionArray(reactionArray, numReactions);

\end{ExampleC}

\subsection{Finding all reactions a species participates in}
On occasion, and typically when investigating the structural
properties of the network, rather than in the course of simulation,
the set of all reactions where a particular species participates as a
substrate (both unary and binary) may be desired.  This can be done
using the function ``int getReactionsInvolving(moleculizer* handle,
char* speciesName, reaction*** ptrReactionPtrArray, int*
numReactions)''.  

\begin{ExampleC}
  /* Find the species involved in the most reactions */

  expandNetwork( handle );

  species** speciesArray;
  int numSpecies;
  getAllSpecies(handle, &speciesArray, &numSpecies);
  

  int mostReactions = -1;
  int speciesNdx;

  char tagBuffer[10];

  for(speciesNdx = 0; speciesNdx != numSpecies; ++speciesNdx)
  {
    reaction** reactionArray;
    int numReactions;

    getReactionsInvolving(handle, speciesArray[speciesNdx]->name, &reactionArray, &numReactions);
    
    if (numReactions > mostReactions)
    {
      mostReactions = numReactions;
      convertIDToTag( handle, speciesArray[speciesNdx]->name, tagBuffer, 10);
    }

  }

  char name[1000];
  convertTagToID( handle, tagBuffer, name, 1000);

  printf(``Species s has greatest connectivity of d'', name, numReactions);

\end{ExampleC}

\subsection{Looking at global properties of the network}
There are four relevant functions involved in finding out the
information about the network as a whole.  The first two are the ``int
getNumberOfSpecies(moleculizer* hdl)'' and ``int
getNumberOfReactions(moleculiser* hdl)'' functions.  These will return
the total number of species and reactions in the reaction network of
the moleculizer object passed in.  Note that this is only the number
that has been generated at that point, not the number in the complete
reaction network.  To find out the complete size of the network, call
the expandNetwork function, in order to ensure that the entire network
has been generated.  

Next, all species and reactions can be read out, using either the
``int getAllSpecies(moleculizer* handle, species*** pSpeciesArray,
int* numberSpecies)'' or the ``int getAllReactions(moleculizer* handle,
reaction*** pSpeciesArray, int* numberSpecies)'' functions.  Their
usage is shown below.

\begin{ExampleC}
moleculizer* handle = createNewMoleculizerObject();
loadRulesFile(handle, some_rules_file);
expandNetwork(handle);

printf(``There are d species and d reactions in the entire
                   network.\n'', getNumberOfSpecies(handle),
                   getNumberOfReactions(handle) ); 

species** speciesArray;
int numSpecies;

reaction** reactionArray;
int numReactions;

getAllSpecies(handle, &speciesArray, &numSpecies);
getAllReactions(handle, &speciesArray, &numSpecies);

if (numSpecies >= 1)
{
  printf(``The first species is s and has approximate radius f.'', speciesArray[0]->name, speciesArray[0]->radius);
}

freeReactionArray(reactionArray, numReactions);
freeSpeciesArray(speciesArray, numSpecies);

freeMoleculizerObject(handle);

\end{ExampleC}

\subsection{Working with Names}

\subsubsection{Tags, canonical ids, and user names}

Libmoleculizer has multiple mechanisms for identifying species:
user-names, tags, canonical ids.  User-names for species are defined
in the mzr file.  In the explicit-species section, users can define
any number of arbitrary complex species and give them arbitrary
names.  Both tags and canonical ids are automatically generated, and
both help uniquely identify complex species, however there are several
key differences.  Tags are short, usually 8 charecters long, and
uniquely identify species within a single libmoleculizer instance.
That is, within a particular libmoleculizer instance, two complex
species are the same if and only if they have the same tag.  However,
tags cannot be compared between instances.  Different species may be
given the same tag and identical species may be given different tags
across program instance boundries.  Furthermore, although tags may be
looked up, species cannot be constructed using its tag.  In contrast,
to each complex species a canonical id is also generated.  The
advantage of the canonical id is twofold.  First, canonical ids
uniquely identify complexes between different instances of
libmoleculizer.  Two species are identical if and only if their
canonical ids are identical, even when the species and ids have been
generated by different instances of libmoleculizer (this is system
independent as well).  Secondly, species can be recreated based on the
canonical id.  If a canonical id is serialized, the corresponding
species can be recreated in any future instance of libmoleculizer
(including, again, across different systems).  The disadvantage of
canonical ids is their potentially large size.  Canonical IDs have
potentially unbounded size, and typically have length that is
proportional to the number of molecules in the complex -- complexes
IDs with length of 750 charectors or greater are not uncommon.

Each of these names has their place.  User-names are typically used to
refer to complicated species is a human-readable way; tags can be used
for tracking species within a running simulation; canonical IDs are
usually used for input/output capabilities.  The remainder of this
section discusses how to work with each type of name, specifically,
how to get the species corresponding to a particular name or tag, and
how to convert between different types of names (finding the
corresponding canonical ID for a particular tag for instance).

\subsubsection{Converting between tags and ids}
Converting between tags and canonical IDs is a very straighforward
procedure.  Depending on which direction conversion is desired, use
either the ``int convertTagToID( moleculizer* handle, char*
speciesTag, char* speciesID, int idSize)'' or the ``int
convertIDToTag( moleculizer* handle, char* speciesID, char*
speciesTag, int tagSize)'' functions.  In both these function, the
first char* parameter takes the name (either the tag or ID) that the
user is converting from.  The second char* parameter is a charector
buffer where the converted name should be put.  The final parameter
takes the size of the destination buffer.  Both these functions return
0 on success and non-zero on failure.  

\begin{ExampleC}

char originalTagName[] = ``0x0384a4'';

char canonicalID[1000];
char newTag[10];

if (convertTagToID( handle, originalTagName, canonicalID, 1000)) printErrorAndQuit();
if (convertIDToTag(handle, canonicalID, newTag, 10)) printErrorAndQuit();

/* This will always succeed.  If it doesn't, send me a bug report! */
assert( !strcmp( origicalTagName, newTag) );

\end{ExampleC}

\subsubsection{User defined names}

In the explicit species section, users can describe complex species
and give them user defined names.  To find either the corresponding
tag or the canonical id for a user defined species, needed for using
the getReactionBetween and getUnaryReactions functions, use either the
functions ``int convertUserNameToSpeciesID(moleculizer* handle, char*
theUserName, char* correspondingSpeciesID, int bufferSize)'' or ``int
convertUserNameToSpeciesID(moleculizer* handle, char* theUserName,
char* correspondingTag, int bufferSize)''. 

\begin{ExampleC}[caption=Example usage of convertUserNameToSpeciesID,
  label=userNameCEx]

  char userName[] = ``alpha-ste2 dimer'';
  char canonicalName[256];
  
  int errorCode;

  convertUserNameToSpeciesID( userName, canonicalName, 256);

  if (errorCode == 0) printf(``The canonical id of %s is %s", userName, canonicalName);
  if (errorCode == 1) printf(``No complex with the user-name '%s' was
                                %defined", userName);
  else if (errorCode == 2) printf(``The char* provided does not have
  enough memory to store the canonical id.'');

\end{ExampleC}

\subsection{Using species streams}
If a species stream is defined in the rules file, this can be looked
up using the function ``int getAllStreamSpecies(moleculizer* handle,
char* streamName, species** pSpeciesArray, int* numberSpecies)''. By
passing in the name of the species stream given in the rules, as well
as a pointer to a species** object.  

\begin{ExampleC}
moleculizer* the_mzr_obj = createNewMoleculizerObject();
loadRulesFule( the_mzr_obj, file_name );
expandNetwork( the_mzr_obj );

char streamName[256] = ``alpha-ste2 complex'';
char** speciesStreamArray;
int numberOfSpeciesInStream;

getAllStreamSpecies(the_mzr_obj, streamName, &speciesStreamArray,
&numberOfSpeciesInStream);

int index;
for( index = 0; index != numberOfSpeciesInStream; ++index)
{
  printf(``s is a s'', speciesStreamArray[index]->name, streamName);
}

\end{ExampleC}

\subsection{Expanding Individual Species}
Many times users will want to expand the reaction network around a
particular species.  What this means is to apply the rules to that
species, generating each of the unary reactions that species can
participate in, as well as generating all the binary reactions that
species can participate in with each already expanded species in the
reaction network.  This can be done either by using the species ID,
the tag, or a pointer to the species itself using any of the functions
``int expandSpeciesByTag( moleculizer* handle, char* theTag)'', ``int
expandSpeciesByID( moleculizer* handle, char* theID)'', or ``int
expandSpecies( moleculizer* handle, species* mzrSpecies)''.

\begin{ExampleC}

char userName[] = ``alpha-ste2 complex'';
char tag[10];

if( convertUserNameToSpeciesTag(handle, userName, tag, 10) ) printErrorAndQuit();

expandSpeciesByTag( handle, tag);

\end{ExampleC}

\subsection{Expanding Individual Reactions}
In addition to expanding individual species, with a reaction* a user
may expand that reaction, which has the same effect as expanding each
of that reaction's products.  This is done using the function ``int
expandReaction(moleculizer* handle, reaction* mzrReaction)''. 

\begin{ExampleC}
  char userName[] = ``alpha-ste2 complex'';

  char speciesID[1000];
  if(convertUserNameToSpeciesID( handle, userName, speciesID, 1000) ) 
  { 
    printErrorAndQuit();
  }

  reaction** reactionArray;
  int numDecompositionRxns;

  getUnaryReactions(handle, speciesID, &reactionArray, &numDecompositionRxns);

  if (numDecompositionRxns > 0)
  {
    expandReaction(handle, reactionArray[0] );
  }
  

\end{ExampleC}










#!/usr/bin/perl
###############################################################################
# Moleculizer - a stochastic simulator for cellular chemistry.
# Copyright (C) 2001  Walter Lawrence (Larry) Lok.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#    
# Contact information:
#   Larry Lok, Research Fellow          Voice: 510-981-8740
#   The Molecular Sciences Institute      Fax: 510-647-0699
#   2168 Shattuck Ave.                  Email: lok@molsci.org
#   Berkeley, CA 94704
###############################################################################

use CGI;

######## Installation-related ###########################################

# Each session has a directory in which all of its files are housed.
# This is where they all live.
$sessions_dir = $ENV{'SERVER_HTDOCS_DIR'} . "/moleculizer/sessions";
# Each library has a directory containing all its entries.  This is
# where all the library directories live.
$libraries_dir = $ENV{'SERVER_HTDOCS_DIR'} . "/moleculizer/libraries";
# This directory contains material for tracking simulation jobs
# in the Condor queue.
$queue_dir = $ENV{'SERVER_HTDOCS_DIR'} . "/moleculizer/queue";

# Dispatch URL for all moleculizer CGI.
$cgi_dispatch_url = $ENV{'MOLECULIZER_SERVER'} . "/cgi-bin/mzr-dispatch";
# URL to find "overflow" HTML documents.
$flat_doc_url = $ENV{'MOLECULIZER_SERVER'} . "/moleculizer/overflow-html";
# URL to get to session files for download.
$sessions_url = $ENV{'MOLECULIZER_SERVER'} . "/moleculizer/sessions";

# Where to look for flattened combination schema/documentation files.
$schema_doc_dir = $ENV{'MOLECULIZER_DIR'} . "/xml/schema/flat";
# Where this program looks for xsl tranformations.
$xsl_dir = $ENV{'MOLECULIZER_DIR'} . "/xml/xsl";
# Where this program looks for boilerplate html.
$flat_doc_dir = $ENV{'MOLECULIZER_DIR'} . "/doc/overflow-html";
# Where to look for session makefiles.
$makefiles_dir = $ENV{'MOLECULIZER_DIR'} . "/session-makefiles";


######## Tasks ##################################################

# Get documentation of a single element or attribute
# of some documented file format.
$mzr_doc_query_task = "mzr-doc-query";

# Make annotated schema.
$mzr_doc_toc_task = "mzr-doc-toc";

# Make element index
$mzr_doc_ndx_task = "mzr-doc-ndx";

# Start a session.
$start_session_task = "start-session";

# Start a session from a library entry.
$start_library_session_task = "start-library-session";

# Start a library session.
$lib_session_task = "lib-session";

# Present form to upload a single file for a simulation session.
$upload_form_task = "upload-form";

# Present form to upload a single file to the library.
$lib_upload_form_task = "lib-upload-form";

# Present form to upload two "connected" files (e.g. moleculizer-input and
# moleculizer-state) to a simulation session.
$upload_two_form_task = "upload-two-form";

# Present form to upload two "connected" files to a library.
$lib_upload_two_form_task = "lib-upload-two-form";

# Actually upload a single file, then present menu.
$upload_file_task = "upload-file";

# Actually upload a single file to the library, then present menu.
$lib_upload_file_task = "lib-upload-file";

# Actually upload two "connected" files to a simulation session, then present
# menu.
$upload_two_files_task = "upload-two-files";

# Actually upload two "connected" files to a library.
$lib_upload_two_files_task = "lib-upload-two-files";

# Display a general menu.
$display_menu_task = "display-menu";

# Tar/compress files directly to the client.
$tgz_task = "tgz";

# Display form for input variation.
$variation_form_task = "variation-form";

# Task to do variation specified in variation form, then present menu.
$vary_file_task = "vary-file";

# Display form to create a range.
$range_form_task = "range-form";

# Start sessions for a range of simulations.  This processes the output
# of a range form.
# 
# How to connect these to the "parent" session?
$range_start_sessions_task = "range-start-sessions";

# Make a session target.  This needs to be implemented both as a subroutine
# and as a task, since many tasks will need to make targets in addition
# to their other chores.
$make_target_task = "make-target";

# Convert all .dmp files in a simulation run directory to .png, generate
# page displaying all the plots.
$view_sim_task = "view-sim";

# Display the current menu for a particular session.
# I think this may be obsolete.
$display_session_menu_task = "display-session-menu";

# Displays menu of queue-related actions.
# This task exists just so that this routine can generate the
# path to the queue directory, rather than arranging for it
# to be in the top-level greeting page by generating the top-level
# greeting page at install time.
$display_queue_menu_task = "display-queue-menu";

# Display an html form to retrieve catch-phrase and email address,
# then queue condor job.
$condor_submit_form_task = "condor-submit-form";

# Actually do the submission of a job to condor queue.
$condor_submit_job_task = "condor_submit_job";

# List jobs in condor queue.
$condor_list_task = "condor-list";

# Remove a cluster from the Condor queue.
$condor_remove_cluster_task = "condor-remove-cluster";

# Display listing of output from atq.
$batch_list_task = "batch-list";

# Display an html form to retrieve catch-phrase, then batch job.
$batch_submit_form_task = "batch-submit-form";

# Actually do the submission of a batch job.
$batch_submit_job_task = "batch-submit-job";

####### Field names used by more than one task.####################

# Main switch for this routine.
$task_field = "task";

# The value of this field isn't really an XPATH; it serves as a key to getting
# documentation out of a grammar-doc file.
$xpath_field = "xpth";

# Name of the schema to get documentation from.
$schema_field = "schema";

# Name of session directory.  How all tasks locate the session directory.
$session_field = "session";

# Name of session makefile.  How session-starting tasks know which kind of
# session to start.
$makefile_field = "makefile";

# Library file for starting a session.
$source_file_path_field = "source-file-path";

# Caption to put on single-file upload form.
$upload_caption_field = "upload-caption";

# Another caption for the two-file upload form.
$upload_caption_two_field = "upload-caption-two";

# Field whose value is the uploaded file handle in single-file upload form.
$uploaded_handle_field = "uploaded-file-handle";

# Field whose value is the second uploaded file handle in two-file upload form.
$uploaded_handle_two_field = "upload-handle-two";

# Field giving name to apply to uploaded file.
$upload_target_field = "upload-target";

# Field giving name of library to focus on.
$library_field = "library";

# Field giving the name of an (uploaded) library item.
$lib_item_field = "lib-item";

# Field giving the name of the file to write the name of the library item
# in.  Clearly, this is getting out of hand.
$lib_item_target_field = "lib-item-target";

# Multiline input field for comments about library items.
$lib_comment_field = "lib-comment";

# Field giving name of file to store library comment in.
$comment_target_field = "comment-target";

# Field giving name of library entry to copy to session, etc.
$lib_entry_field = "lib-entry";

# Field giving name to apply to second uploaded file in two-file form.
$upload_target_two_field = "upload-target-two";

# Field giving name of "proxy target" that indicates that a certain task
# has been performed.
$proxy_target_field = "proxy-target";

# Field giving actual target for make-target task.
$make_target_field = "target";

# Field giving name of file on which to do variation.
$variation_source_field = "variation-source";

# Field giving name of file to receive variation.
$variation_target_field = "variation-target";

# Field giving caption for variation form.
$variation_caption_field = "variation-caption";

# Field giving simulation directory for viewing.
$view_sim_field = "view-sim";

# Field giving caption for viewed simulation.
$view_caption_field = "view-caption";

# Field telling whether a range is "additive" or "multiplicative".
$range_type_field = "range-type";

# Field telling the starting value of a range.
$range_start_field = "range-start";

# Field telling the delta (or factor) by which to increase the
# value in each step of a range.
$range_delta_field = "range-delta";

# Field telling how many increments are in a range.
$range_count_field = "range-count";

# Field giving the stem for constructing catch-phrases for the
# simulations in a range.
$range_catch_phrase_field = "range-catch-phrase";

# Field giving xpath to variable to vary in a range.
$range_xpth_field = "range-xpth";

# Field giving working directory for general menu display task.
$working_dir_field = "working-dir";

# Field giving menu for general menu display task.
$menu_field = "menu";

# Field giving base directory for tgz task.
$tar_base_dir_field = "tar-base-dir";

# Field giving file to tar in tgz task.
$tar_source_field = "tar-source";

# Field giving catch-phrase for a queued job.
$catch_phrase_field = "catch-phrase";

# Field giving user's email address for queued job.
$reply_email_field = "reply-email";

# Field giving Condor cluster to remove.
$condor_cluster_field = "condor-cluster";

###### Subroutines ##################################################

$query = new CGI;

# Converts XPATH field names and values from variation form into XSLT
# tranformation that gives the values to the attributes specified by
# the XPATHs.
sub writeXpathTransformer
{
    # Only argument is name of target XSLT file.
    my ($xsl_tmp) = @_;

    @names = $query->param;

    # Open a temporary XSL transformation file for output.
    open(XSL_TMP, ">$xsl_tmp");

    # Write header stuff to XSL file.
    print XSL_TMP '<?xml version="1.0" encoding="UTF-8"?>';
    print XSL_TMP '<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">';
    print XSL_TMP '<xsl:output method="xml"/>';

    # Write basic copying template to XSL file.
    print XSL_TMP '<xsl:template match="node() | @*">';
    print XSL_TMP   '<xsl:copy>';
    print XSL_TMP     '<xsl:apply-templates select="@* | node()"/>';
    print XSL_TMP   '</xsl:copy>';
    print XSL_TMP '</xsl:template>';

    # Write a template for each xpath, value pair.
    foreach $name (@names)
    {
	# Get only names starting with /, which should be all and only
	# XPATH's.
	if($name =~ /^\//)
	{
	    # Do NOT just put the rhs here into the print statement!
	    # It can return a list, all of whose members get printed.
	    # We want to evaluate it in scalar context like this.
	    $value = $query->param($name);

	    print XSL_TMP "<xsl:template match=\"$name\">";
	    print XSL_TMP   '<xsl:attribute name="{name()}">';
	    print XSL_TMP     $value;
	    print XSL_TMP   '</xsl:attribute>';
	    print XSL_TMP '</xsl:template>';
	}
    }

    # Write trailer stuff to XSL file.
    print XSL_TMP '</xsl:stylesheet>';
    close XSL_TMP;
}

sub uploadFile
{
    my ($postedFileHandle, $targetFileName) = @_;

    open(TARGET_FILE_HANDLE, ">$targetFileName")
	or die("Could not open upload target file $targetFileName.\n");

    # Here, I need to constrain the size of the uploaded file,
    while(<$postedFileHandle>)
    {
	print TARGET_FILE_HANDLE $_;
    }
    close(TARGET_FILE_HANDLE);
}

# Just an ordinary file copy.
sub copyFile
{
    my ($source_path, $target_path) = @_;

    # Why not just use cp?

    print STDERR "copyFile: copying $source_path to $target_path\n";

    open(SOURCE_HANDLE, $source_path)
	or die("copyFile: could not open source file $source_path.");
    open(TARGET_HANDLE, ">$target_path")
	or die("copyFile: could not open target file $target_path.");

    while(<SOURCE_HANDLE>)
    {
	print TARGET_HANDLE $_;
    }

    close SOURCE_HANDLE;
    close TARGET_HANDLE;
}

# Copy directory contents.  Both directories assumed to exist.
sub copyDirContents
{
    my ($source_dir, $target_dir) = @_;

    system("cp $source_dir/* $target_dir");
}

# Writes the named file to stdout.
sub catFile
{
    my ($source_file_name) = @_;

    # Why not just use cat?

    open(SOURCE_FILE, $source_file_name)
	or die("Could not open source file $source_file_name for cat.\n");
    while(<SOURCE_FILE>)
    {
	print;
    }
    close(SOURCE_fILE);
}

sub writeVariationForm
{
    my ($session,
	$variation_source,
	$variation_target,
	$schema,
	$caption,
	$proxy_target,
	$output_file_path) = @_;

    $path_doc_url
	= $cgi_dispatch_url
	. "?task="
	. $mzr_doc_query_task
	. "&"
	. $schema_field
	. "="
	. $schema
	. "&"
	. $xpath_field
	. "=";

    $session_dir = "$sessions_dir/$session";
    $source_file_path = "$session_dir/$variation_source";

    # Run the XSLT transformation.
    system("java", "org.apache.xalan.xslt.Process",
	   "-in", "$source_file_path",
	   "-xsl", "$xsl_dir/mzr2form.xsl",
	   "-param", "action-url", "$cgi_dispatch_url",
	   "-param", "path-doc-url", "$path_doc_url",
	   "-param", "caption", "$caption",
	   "-param", "schema-doc-file-path", "$schema_doc_dir/$schema",
	   "-param", "variation-source", "$variation_source",
	   "-param", "variation-target", "$variation_target",
	   "-param", "session", "$session",
	   "-param", "proxy-target", "$proxy_target",
	   "-html",
	   "-out", "$output_file_path");
}

sub writeRangeForm
{
    my ($session,
	$variation_source,
	$variation_target,
	$schema,
	$caption,
	$proxy_target,
	$output_file_path) = @_;

    $path_doc_url
	= $cgi_dispatch_url
	. "?task="
	. $mzr_doc_query_task
	. "&"
	. $schema_field
	. "="
	. $schema
	. "&"
	. $xpath_field
	. "=";

    $session_dir = "$sessions_dir/$session";
    $source_file_path = "$session_dir/$variation_source";

    # Run the XSLT transformation.
    system("java", "org.apache.xalan.xslt.Process",
	   "-in", "$source_file_path",
	   "-xsl", "$xsl_dir/mzr2range.xsl",
	   "-param", "action-url", "$cgi_dispatch_url",
	   "-param", "path-doc-url", "$path_doc_url",
	   "-param", "caption", "$caption",
	   "-param", "schema-doc-file-path", "$schema_doc_dir/$schema",
	   "-param", "variation-source", "$variation_source",
	   "-param", "variation-target", "$variation_target",
	   "-param", "session", "$session",
	   "-param", "proxy-target", "$proxy_target",
	   "-html",
	   "-out", "$output_file_path");
}

sub makeSessionTarget
{
    my ($session_dir, $target) = @_;

    print STDERR "Making target $target in $session_dir.\n";

#    system("cd $session_dir && make $target >> session-log 2>&1");

    # For debugging.
    system("cd $session_dir && make $target >> session-log");
}

sub writeMenu
{
    my ($session_dir, $menu) = @_;

    makeSessionTarget($session_dir, "menu-clean");
    makeSessionTarget($session_dir, $menu);

    # There seems to be a problem with menus being cached by the browser.
    # Also, the usual way of generating the content-type header,
    # $query->header(), seems to interfere with the "pragma" in some
    # way.  This is straight out of the CGI book, and seems to work.
    print "Content-type: text/html\n";
    print "Pragma: no-cache\n\n";

    catFile("$session_dir/$menu");
}


##### The script #######################################################

$task = $query->param($task_field);

print STDERR ("Task is $task.\n");

if($task eq $mzr_doc_query_task)
{
    # Get simplified XPATH of element or attribute whose documentation
    # is being called for.
    $xpath = $query->param($xpath_field);

    # Get the schema/documentation file.
    $schema_file = $query->param($schema_field);

    # The URL of the documentation script.  All you need to do is attach
    # the funky xpath.
    $path_doc_url
	= $cgi_dispatch_url
	. "?task="
	. $mzr_doc_query_task
	. "&"
	. $schema_field
	. "="
	. $schema_file
	. "&"
	. $xpath_field
	. "=";

    # For table-of-contents link on each man page.
    $toc_doc_url
	= $cgi_dispatch_url
	. "?task="
	. $mzr_doc_toc_task
	. "&"
	. $schema_field
	. "="
	. $schema_file;

    # For index link on each man page.
    $ndx_doc_url
	= $cgi_dispatch_url
	. "?task="
	. $mzr_doc_ndx_task
	. "&"
	. $schema_field
	. "="
	. $schema_file;

    # Choose a name for a temporary file to hold the html page.
    $tmpfile = "/tmp/mzr-doc-cgi-$$";

    # Run XSLT tranformation on the schema/doc file to extract documentation
    # on the requested element or attribute. Puts result into the temp file
    # for now; I should be able to use a FIFO for this.
    #
    # Now that I'm flattening the schema/documentation file, the
    # rng-include-path parameter of rngpth.xsl is no longer needed.
    system("java", "org.apache.xalan.xslt.Process",
	   "-in", "$schema_doc_dir/$schema_file",
	   "-xsl", "$xsl_dir/rngpth.xsl",
	   "-param", "input-search-path", "$xpath",
	   "-param", "path-doc-url", "$path_doc_url",
	   "-param", "flat-doc-url", "$flat_doc_url",
	   "-param", "toc-doc-url", "$toc_doc_url",
	   "-param", "ndx-doc-url", "$ndx_doc_url",
	   "-html",
	   "-out", "$tmpfile");

    # Print the content-type header; defaulting to html.  Note that this
    # has to be done in each task that actually emits a web page (rather
    # than a redirection.)
    print $query->header();

    # cat the tmp file to stdout.
    catFile($tmpfile);

    # Remove the temporary file.
    unlink($tmpfile);
}
elsif($task eq $mzr_doc_toc_task)
{
    # Get the schema to convert to table of contents.
    $schema_file = $query->param($schema_field);

    # The URL of the documentation script.  All you need to do is attach
    # the funky xpath.
    $path_doc_url
	= $cgi_dispatch_url
	. "?task="
	. $mzr_doc_query_task
	. "&"
	. $schema_field
	. "="
	. $schema_file
	. "&"
	. $xpath_field
	. "=";

    # Choose a name for a temporary file to hold the html page.
    $tmpfile = "/tmp/mzr-doc-toc-cgi-$$";

    # Again, I should be able to do this with a FIFO.  Avoiding this
    # and avoiding spinning up java again and again could be done with
    # servlets instead of cgi?
    system("java", "org.apache.xalan.xslt.Process",
	   "-in", "$schema_doc_dir/$schema_file",
	   "-xsl", "$xsl_dir/rng-doc-toc.xsl",
	   "-param", "path-doc-url", "$path_doc_url",
	   "-param", "caption", "$schema_file table of contents",
	   "-html",
	   "-out", "$tmpfile");

    # Print the content-type header; defaulting to html.  Note that this
    # has to be done in each task that actually emits a web page (rather
    # than a redirection.)
    print $query->header();

    # cat the tmp file to stdout.
    catFile($tmpfile);

    # Remove the temporary file.
    unlink($tmpfile);
}
elsif($task eq $mzr_doc_ndx_task)
{
    # Get the schema to convert to table of contents.
    $schema_file = $query->param($schema_field);

    # The URL of the documentation script.  All you need to do is attach
    # the funky xpath.
    $path_doc_url
	= $cgi_dispatch_url
	. "?task="
	. $mzr_doc_query_task
	. "&"
	. $schema_field
	. "="
	. $schema_file
	. "&"
	. $xpath_field
	. "=";

    # Choose a name for a temporary file to hold the html page.
    $tmpfile = "/tmp/mzr-doc-toc-cgi-$$";

    # Again, I should be able to do this with a FIFO.  Avoiding this
    # and avoiding spinning up java again and again could be done with
    # servlets instead of cgi?
    system("java", "org.apache.xalan.xslt.Process",
	   "-in", "$schema_doc_dir/$schema_file",
	   "-xsl", "$xsl_dir/rng-doc-ndx.xsl",
	   "-param", "path-doc-url", "$path_doc_url",
	   "-param", "caption", "$schema_file element index",
	   "-html",
	   "-out", "$tmpfile");

    # Print the content-type header; defaulting to html.  Note that this
    # has to be done in each task that actually emits a web page (rather
    # than a redirection.)
    print $query->header();

    # cat the tmp file to stdout.
    catFile($tmpfile);

    # Remove the temporary file.
    unlink($tmpfile);
}
elsif($task eq $start_session_task)
{
    $session = "session-$$";
    $session_dir = "$sessions_dir/$session";

    # Get the name of the makefile to use in the session.
    $session_makefile_name = $query->param($makefile_field);

    print STDERR "start-session: makefile is $session_makefile_name.\n";

    # Create session directory with rwx--rwx permissions.
    mkdir($session_dir, 0707)
	or die "Could not make session directory $session_dir.";
    
    # Copy the appropiate makefile into the session directory.
    $session_makefile_path = "$makefiles_dir/$session_makefile_name";
    $target_makefile_path = "$session_dir/makefile";
    copyFile($session_makefile_path, $target_makefile_path);

    # Emit menu of things that can be done using makefile of session
    # directory.
    writeMenu($session_dir, "whats-next.html");
}
elsif($task eq $start_library_session_task)
{
    $session = "session-$$";
    $session_dir = "$sessions_dir/$session";

    # Create session directory with rwx--rwx permissions.
    mkdir($session_dir, 0707)
	or die "Could not make session directory $session_dir.";

    # Get the name of the makefile to use in the session.
    $session_makefile_name = $query->param($makefile_field);

    print STDERR "start-session: makefile is $session_makefile_name.\n";

    # Copy the appropiate makefile into the session directory.
    $session_makefile_path = "$makefiles_dir/$session_makefile_name";
    $target_makefile_path = "$session_dir/makefile";
    copyFile($session_makefile_path, $target_makefile_path);

    # Copy the contents of the library entry directory into the session
    # directory.
    $library = $query->param($library_field);
    $library_dir = "$libraries_dir/$library";
    $lib_entry = $query->param($lib_entry_field);
    $entry_dir = "$library_dir/$lib_entry";
    copyDirContents($entry_dir, $session_dir);

    # Make the proxy target in the session directory to indicate
    # that the initial simulation source file is already present.
    $proxy_target = $query->param($proxy_target_field);
    makeSessionTarget($session_dir, $proxy_target);

    # Emit menu of things that can be done using makefile of session
    # directory.
    writeMenu($session_dir, "whats-next.html");
}
elsif($task eq $lib_session_task)
{
    $library = $query->param($library_field);
    $library_dir = "$libraries_dir/$library";

    print STDERR "lib-session-task: library_dir is $library_dir.\n";

    writeMenu($library_dir, "whats-next.html");
}
elsif($task eq $upload_form_task)
{
    $session = $query->param($session_field);
    $session_dir = "$sessions_dir/$session";

    $target_file = $query->param($upload_target_field);
    $caption = $query->param($upload_caption_field);
    $proxy_target = $query->param($proxy_target_field);
    
    # Generate the upload form
    
    # Print the content-type header; defaulting to html.  Note that this
    # has to be done in each task that actually emits a web page (rather
    # than a redirection.)
    print $query->header;

    # Print the html header.
    print $query->start_html(-title => 'Upload file');

    # Print banner.
    print $query->h1($caption);

    # Start a POST-method form.
    print $query->start_multipart_form(-method => POST,
				       -action => $cgi_dispatch_url);

    # Input field for file.
    print $query->p($query->filefield(-name => $uploaded_handle_field));

    # Submit button.
    print $query->p($query->submit(-name => "Upload"));

    # Which session is this?  Now my reading of the functionality
    # of the CGI object makes it look like $session might be redundant?
    print $query->hidden($session_field, $session);

    # Where to put uploaded file in session directory.  This has to be
    # done by the upload-file task.  A stupid Perl trick here implies
    # that the field values that are present in the query are reused
    # unless one makes a special call $query->param.  Values specified
    # in, say, $query->hidden are used only if there is not already
    # a value for the named field.
    print $query->hidden($upload_target_field);

    # Task that will handle the submission.
    # Have to call param here because of the stupid Perl trick.
    $query->param($task_field, $upload_file_task);
    print $query->hidden($task_field);

    print STDERR "Task should be $upload_file_task.\n";

    print STDERR $query->hidden($task_field), "\n";

    # Proxy make target that upload-file will use to indicate that the file
    # has been uploaded.  Don't need to call param here because field valus
    # should remain unchanged.
    print $query->hidden($proxy_target_field);

    # End form
    print $query->endform;

    # End html.
    print $query->end_html;
}
elsif($task eq $upload_file_task)
{
    $session = $query->param($session_field);
    $session_dir = "$sessions_dir/$session";

    $posted_file_handle = $query->param($uploaded_handle_field);
    $target_file = $query->param($upload_target_field);
    $proxy_target = $query->param($proxy_target_field);

    # Do the actual file upload.
    $target_path = "$session_dir/$target_file";
    uploadFile($posted_file_handle, $target_path);

    # Make the proxy target to indicate that the file has been uploaded,
    # so that upload will no longer appear in the menu.
    makeSessionTarget($session_dir, $proxy_target);

    # Display the menu.
    writeMenu($session_dir, "whats-next.html");
}
elsif($task eq $upload_two_form_task)
{
    $upload_caption = $query->param($upload_caption_field);
    $upload_caption_two = $query->param($upload_caption_two_field);
    $proxy_target = $query->param($proxy_target_field);

    # Print content-type header.
    print $query->header;

    # Print HTML header.
    print $query->start_html(-title => 'Upload two files');

    # Print banner.
    print $query->h1('Upload two files');

    # Start a POST-method form.
    print $query->start_multipart_form(-method => POST,
				       -action => $cgi_dispatch_url);

    # Input field for first file.
    print $query->p($upload_caption,
		    $query->filefield(-name => $uploaded_handle_field));

    # Input field for second file.
    print $query->p($upload_caption_two,
		    $query->filefield(-name => $uploaded_handle_two_field));

    # Submit button
    print $query->p($query->submit(-name => 'Upload'));

    print $query->hidden($session_field);
    print $query->hidden($upload_target_field);
    print $query->hidden($upload_target_two_field);
    print $query->hidden($proxy_target_field);
    $query->param($task_field, $upload_two_files_task);
    print $query->hidden($task_field);

    # End form.
    print $query->endform;

    # End html.
    print $query->end_html;
}
elsif($task eq $upload_two_files_task)
{
    $session = $query->param($session_field);
    $session_dir = "$sessions_dir/$session";

    $uploaded_handle = $query->param($uploaded_handle_field);
    $uploaded_handle_two = $query->param($uploaded_handle_two_field);
    $upload_target = $query->param($upload_target_field);
    $upload_target_two = $query->param($upload_target_two_field);
    $proxy_target = $query->param($proxy_target_field);

    # Do the actual file uploads.
    $target_path = "$session_dir/$upload_target";
    uploadFile($uploaded_handle, $target_path);

    $target_path_two = "$session_dir/$upload_target_two";
    uploadFile($uploaded_handle_two, $target_path_two);

    # Make the proxy target to indicate that the file has been uploaded,
    # so that upload will no longer appear in the menu.
    makeSessionTarget($session_dir, $proxy_target);

    # Display the menu.
    writeMenu($session_dir, "whats-next.html");
}
elsif($task eq $lib_upload_form_task)
{
    # Which library to upload to.  For now, using a three-part
    # structure in the library, corresponding to the three
    # kinds of sessions.
    $library = $query->param($library_field);

    # Print content type header.
    print $query->header;

    # Print html header.
    $title = "Upload file to $library library";
    print $query->start_html(-title => $title);

    # Print banner.
    print $query->h1($title);

    # Start a POST-method form.
    print $query->start_multipart_form(-method => POST,
				       -action => $cgi_dispatch_url);

    # For some reason, tr, etc aren't in the CGI module.  Probably
    # deemed to be too short to be worth it.
    print $query->table("<tr>",
			"<th>", "Item name", "</th>",
			"<td>", $query->textfield(-name => $lib_item_field), "</td>",
			"</tr>",
			"<tr>",
			"<th>", "Description", "</th>",
			"<td>", $query->textarea(-name => $lib_comment_field,
						 -rows => 6,
						 -columns => 30), "</td>",
			"</tr>",
			"<tr>",
			"<th>", "File to upload", "</th>",
			"<td>",	$query->filefield(-name => $uploaded_handle_field), "</td>",
			"</tr>");

    # Submit button.
    print $query->p($query->submit(-name => "Upload"));

    # Hidden fields for communication to (and selection of)
    # $lib_upload_file_task.
    print $query->hidden($library_field);
    print $query->hidden($upload_target_field);
    print $query->hidden($comment_target_field);
    print $query->hidden($lib_item_target_field);
    print $query->hidden($proxy_target_field);
    $query->param($task_field, $lib_upload_file_task);
    print $query->hidden($task_field);

    # End form.
    print $query->endform;

    # End html.
    print $query->end_html;
}
elsif($task eq $lib_upload_file_task)
{
    $library = $query->param($library_field);
    $library_dir = "$libraries_dir/$library";

    $upload_target = $query->param($upload_target_field);
    $proxy_target = $query->param($proxy_target_field);

    # An alternative I've considered here is to combine the uploaded
    # documents, comment, and library item name into a single, loosely
    # structured XML document, then extract its pieces by XSLT.  Right
    # now, I don't see any particular advantage to that approach.

    # Construct the directory for the library entry to be
    # created, with rwx---rwx permissions.
    $entry_dir = "$library_dir/entry-$$";
    mkdir($entry_dir, 0707)
	or die("Could not make library entry directory $entry_dir.\n");

    # Do the actual file upload.
    $target_path = "$entry_dir/$upload_target";
    $posted_file_handle = $query->param($uploaded_handle_field);
    uploadFile($posted_file_handle, $target_path);

    # Write file containing the name to display for the library
    # item.
    $lib_item = $query->param($lib_item_field);
    $lib_item_target = $query->param($lib_item_target_field);
    $lib_item_target_path = "$entry_dir/$lib_item_target";
    open(ITEM, ">$lib_item_target_path");
    print ITEM $lib_item;
    close(ITEM);

    # Write comment file.
    $lib_comment = $query->param($lib_comment_field);
    $comment_target = $query->param($comment_target_field);
    $comment_target_path = "$entry_dir/$comment_target";
    open(COMMENT, ">$comment_target_path");
    print COMMENT $lib_comment;
    close(COMMENT);

    # Make the proxy target.  This assumes the makefile resides in the
    # directory containing all the library entries.
    $proxy_target = $query->param($proxy_target_field);
    makeSessionTarget($library_dir, $proxy_target);

    # Display the library menu.
    writeMenu($library_dir, "whats-next.html");
}
elsif($task eq $lib_upload_two_form_task)
{
    # This task presents a form for uploading two files into a single
    # library item.

    # Which library to upload to.
    $library = $query->param($library_field);

    # Captions for the two files to upload.
    $upload_caption = $query->param($upload_caption_field);
    $upload_caption_two = $query->param($upload_caption_two_field);

    # Print the content type header.
    print $query->header;

    # Print HTML header.
    $title = "Upload files to $library library";
    print $query->start_html(-title => $title);

    # Print banner.
    print $query->h1($title);

    # Start a POST-method form.
    print $query->start_multipart_form(-method => POST,
				       -action => $cgi_dispatch_url);

    # As noted above, CGI module doesn't seem to have all table building
    # tags in it.
    print $query->table("<tr>",
			"<th>", "Item name", "</th>",
			"<td>", $query->textfield(-name => $lib_item_field), "</td>",
			"</tr>",
			"<tr>",
			"<th>", "Description", "</th>",
			"<td>", $query->textarea(-name => $lib_comment_field,
						 -rows => 6,
						 -columns => 30), "</td>",
			"</tr>",
			"<tr>",
			"<th>", $upload_caption, "</th>",
			"<td>",	$query->filefield(-name => $uploaded_handle_field), "</td>",
			"</tr>",
			"<tr>",
			"<th>", $upload_caption_two, "</th>",
			"<td>",	$query->filefield(-name => $uploaded_handle_two_field), "</td>",
			"</tr>");

    # Submit button
    print $query->p($query->submit(-name => "Upload"));

    # Hidden fields to communicate to $lib_upload_two_files_task.
    print $query->hidden($library_field);
    print $query->hidden($upload_target_field);
    print $query->hidden($upload_target_two_field);
    print $query->hidden($comment_target_field);
    print $query->hidden($lib_item_target_field);
    print $query->hidden($proxy_target_field);
    $query->param($task_field, $lib_upload_two_files_task);
    print $query->hidden($task_field);

    # End form
    print $query->endform;

    # End html.
    print $query->end_html;
}
elsif($task eq $lib_upload_two_files_task)
{
    # This task actually uploads two files to a library, as specified
    # in the form presented by $lib_upload_two_form_task.

    # Name to the library to upload to.
    $library = $query->param($library_field);
    $library_dir = "$libraries_dir/$library";

    # Name to give the first uploaded file in the library entry directory.
    $upload_target = $query->param($upload_target_field);
    # Name to give the second uploaded file in the library entry directory.
    $upload_target_two = $query->param($upload_target_two_field);
    # Proxy target to make in the library directory.
    $proxy_target = $query->param($proxy_target_field);

    # Construct the library entry directory, with rwx---rwx permission.
    $entry_dir = "$library_dir/entry-$$";
    mkdir($entry_dir, 0707)
	or die("Could not make library entry directory $entry_dir.\n");

    # Upload the first file.
    $target_path = "$entry_dir/$upload_target";
    $uploaded_handle = $query->param($uploaded_handle_field);
    uploadFile($uploaded_handle, $target_path);

    # Upload the second file.
    $target_path_two = "$entry_dir/$upload_target_two";
    $uploaded_handle_two = $query->param($uploaded_handle_two_field);
    uploadFile($uploaded_handle_two, $target_path_two);

    # Write file containing the name to display for the library item.
    $lib_item = $query->param($lib_item_field);
    $lib_item_target = $query->param($lib_item_target_field);
    $lib_item_target_path = "$entry_dir/$lib_item_target";
    open(ITEM, ">$lib_item_target_path");
    print ITEM $lib_item;
    close(ITEM);

    # Write file containing the user's comment for this library
    # entry.
    $lib_comment = $query->param($lib_comment_field);
    $comment_target = $query->param($comment_target_field);
    $comment_target_path = "$entry_dir/$comment_target";
    open(COMMENT, ">$comment_target_path");
    print COMMENT $lib_comment;
    close(COMMENT);

    # Make the proxy target.  This assumes the makefile resides in the
    # directory containing all the library entries.
    $proxy_target = $query->param($proxy_target_field);
    makeSessionTarget($library_dir, $proxy_target);

    # Display the library menu.
    writeMenu($library_dir, "whats-next.html");
}
elsif($task eq $variation_form_task)
{
    $session = $query->param($session_field);
    $session_dir = "$sessions_dir/$session";

    $variation_source = $query->param($variation_source_field);
    $schema = $query->param($schema_field);
    $variation_caption = $query->param($variation_caption_field);
    $variation_target = $query->param($variation_target_field);
    $proxy_target = $query->param($proxy_target_field);

    print STDERR "variation-form: proxy target is $proxy_target.\n";

    # Write variation form to temp file, because Xalan always puts its output
    # in a file.
    $form_tmp_file = "/tmp/variation-form-$$";
    writeVariationForm($session,
		       $variation_source,
		       $variation_target,
		       $schema,
		       $variation_caption,
		       $proxy_target,
		       $form_tmp_file);

    # Print the content-type header; defaulting to html.  Note that this
    # has to be done in each task that actually emits a web page (rather
    # than a redirection.)
    print $query->header();

    # Emit tmp file.
    catFile($form_tmp_file);

    # Remove tmp file.
    unlink($form_tmp_file);
}
elsif($task eq $vary_file_task)
{
    $session = $query->param($session_field);
    $session_dir = "$sessions_dir/$session";

    $variation_source = $query->param($variation_source_field);
    $variation_target = $query->param($variation_target_field);
    $proxy_target = $query->param($proxy_target_field);

    # Temporary file to receive transformed input file.
    # This is to guarantee that it's possible to run the variation back
    # into the original input file.
    $variation_tmp = "/tmp/variation-tmp-target-$$";

    # Write the XSL transformation to a temp file
    # using incoming xpth/value pairs.
    $xsl_tmp = "/tmp/variation-xsl-tmp-$$";
    writeXpathTransformer($xsl_tmp);

    # Run the transformation.
    system("java", "org.apache.xalan.xslt.Process",
	   "-in", "$session_dir/$variation_source",
	   "-xsl", "$xsl_tmp",
	   "-xml",
	   "-out", $variation_tmp);

    # Move the temporary into the variation_target.
    rename($variation_tmp, "$session_dir/$variation_target");

    # Delete the temp XSL file.
    unlink($xsl_tmp);

    # Make the proxy target, to indicate that the variation has been done.
    makeSessionTarget($session_dir, $proxy_target);

    # Diplay menu.
    writeMenu($session_dir, "whats-next.html");
}
elsif($task eq $range_form_task)
{
    $session = $query->param($session_field);
    $session_dir = "$sessions_dir/$session";

    $variation_source = $query->param($variation_source_field);
    $schema = $query->param($schema_field);
    $variation_caption = $query->param($variation_caption_field);
    $variation_target = $query->param($variation_target_field);
    $proxy_target = $query->param($proxy_target_field);

    # Write variation form to temp file, because Xalan always puts its output
    # in a file.
    $form_tmp_file = "/tmp/range-form-$$";
    writeRangeForm($session,
		   $variation_source,
		   $variation_target,
		   $schema,
		   $variation_caption,
		   $proxy_target,
		   $form_tmp_file);

    # Print the content-type header; defaulting to html.  Note that this
    # has to be done in each task that actually emits a web page (rather
    # than a redirection.)
    print $query->header();

    # Emit tmp file.
    catFile($form_tmp_file);

    # Remove tmp file.
    unlink($form_tmp_file);
}
elsif($task eq $range_start_sessions_task)
{
    $session = $query->param($session_field);
    $session_dir = "$sessions_dir/$session";
    $session_makefile = "$session_dir/makefile";
    # This is a bad reuse of this field name.
    $variation_source = $query->param($variation_source_field);
    $range_source = "$session_dir/$variation_source";
    $proxy_target = $query->param($proxy_target_field);

    $range_type = $query->param($range_type_field);
    $range_start = $query->param($range_start_field);
    $range_delta = $query->param($range_delta_field);
    $range_count = $query->param($range_count_field);
    $range_catch_phrase = $query->param($range_catch_phrase_field);
    $range_xpth = $query->param($range_xpth_field);

    if($range_type eq "additive")
    {
	$new_value = $range_start;
	for($range_index = 0; $range_index < $range_count; ++$range_index)
	{
	    # Create session directory for this variation.
	    $variation_session = "$session.$range_index";
	    $variation_session_dir = "$sessions_dir/$variation_session";
	    mkdir($variation_session_dir, 0707)
		or die "Could not make variation session directory $variation_session_dir.";

	    # Copy the makefile from the current session into the variation
	    # session directory.
	    $variation_session_makefile = "$variation_session_dir/makefile";
	    copyFile($session_makefile, $variation_session_makefile);

	    # Generate the variation file into the variation session directory.
	    $new_file = "$variation_session_dir/$variation_source";
	    system("vary-param $range_source $range_xpth $new_value $new_file");
	    # Make the submit file in the variation session directory.
	    makeSessionTarget($variation_session_dir, "batch-submit-file");
	    
	    # Read output of batch submission.
	    open(BATCH_SUBMIT, "cd $variation_session_dir && batch -f batch-submit-file 2>&1 |");
	    while(<BATCH_SUBMIT>)
	    {
		if(m/^job/)
		{
		    ($the_word_job, $job_number, $the_word_at, $date, $time) = split;
		}
	    }
	    close BATCH_SUBMIT;

	    $catch_phrase = "$range_catch_phrase-$range_index";
	    
	    print STDERR "Submitted variation job $job_number on $date at $time with catch phrase $catch_phrase\n";

	    # For the link back to the session from its entry in the
	    # list of queued jobs.
	    $session_menu_url = $cgi_dispatch_url
		. "?$task_field=$display_session_menu_task"
		. "&$session_field=$variation_session";

	    # Write job number, session, and catch phrase to catalog of jobs.
	    # Note that we need to use percent as a separator here, since catch
	    # phrases my have spaces in them.
	    open(BATCH_MAP, ">> $queue_dir/batch_map");
	    print BATCH_MAP "$job_number%$variation_session%$catch_phrase%$date%$time\n";
	    close BATCH_MAP;

	    # Make the proxy target indicating that the queued job
	    # has been started.
	    makeSessionTarget($variation_session_dir, $proxy_target);
	    
	    $new_value = $new_value + $range_delta;
	}
    }
    elsif($range_type eq "multiplicative")
    {
	    # For now, just generate the variation files into the session
	    # directory.
	    $new_file = "$session_dir/variation-$range_index";

	    system("vary-param $range_source $range_xpth $new_value $new_file");
	    $new_value = $new_value * $range_delta;
    }
    else
    {
	die("Unknown range type $range_type.\n");
    }

    # For now, this doesn't actually start any simulations, so we
    # just go back to the session menu.
    writeMenu($session_dir, "whats-next.html");
}
elsif($task eq $view_sim_task)
{
    $session = $query->param($session_field);
    $session_dir = "$sessions_dir/$session";
    $session_url = "$sessions_url/$session";

    $view_sim = $query->param($view_sim_field);
    $view_sim_dir = "$session_dir/$view_sim";
    $view_sim_url = "$session_url/$view_sim";

    $view_caption = $query->param($view_caption_field);

    # Plot the .dmp files in the simulation directory.
    system("cd $view_sim_dir && plot-dmp-files");

    # Print the content-type header.
    print $query->header;

    # Print the html header.
    print $query->start_html(-title => $view_caption);

    # Print a banner.
    print $query->h1($view_caption);
    print "<hr/>";
    print " <ul>\n";
    print "  <li><a href='$view_sim_url/job.err'>errors</a></li>\n";
    print "  <li><a href='$view_sim_url/job.log'>log</a></li>\n";
    print "  <li><a href='$view_sim_url/job.out'>text output</a></li>\n";
    print "  <li><a href='$cgi_dispatch_url?$task_field=$display_session_menu_task&$session_field=$session'>what's next?</a></li>\n";
    print " </ul>\n";
    print "<hr/>\n";
    print $query->p('Plots of simulation output files with ".dmp" suffix.');

    # Insert all the plotted dump files as images.
    opendir(SIM_RUN_DIR, $view_sim_dir);
    @pngfiles = grep(/\.png/, readdir(SIM_RUN_DIR));
    closedir(SIM_RUN_DIR);
    foreach $pngfile (@pngfiles)
    {
	$img_url = "$view_sim_url/$pngfile";
	print $query->p($query->img({-src=>"$img_url"}));
    }

    # Print html footer.
    print $query->end_html;
}
elsif($task eq $display_session_menu_task)
{
    # I think this may really be obsolete.  The only reason I can think of
    # for it to exist would be similar to the $display_queue_menu_task,
    # which exists in order that this script can generate the path to
    # the queue directory, rather than putting it into the top-level
    # greeting html page.  That would mean that the top-level page would
    # have to generated at install time.
    $session = $query->param($session_field);
    $session_dir = "$sessions_dir/$session";

    writeMenu($session_dir, "whats-next.html");
}
elsif($task eq $display_queue_menu_task)
{
    # This task exists in order that this script can generate the path to
    # the queue directory, rather than putting it into the top-level
    # greeting html page.  That would mean that the top-level page would
    # have to generated at install time.

    writeMenu($queue_dir, "whats-next.html");
}
elsif($task eq $display_menu_task)
{
    # Should the above 'display_session_menu_task' go away?
    $working_dir = $query->param($working_dir_field);
    $menu = $query->param($menu_field);

    writeMenu($working_dir, $menu);
}
elsif($task eq $tgz_task)
{
    # Path to the directory that should be the base directory
    # of the tar archive; i.e. the directory that we cd to before
    # making the tar archive.
    $tar_base_dir = $query->param($tar_base_dir_field);
    # Relative path of the file/directory to put into the archive.
    $tar_source = $query->param($tar_source_field);

    # How does the browser usually get the name of a file you
    # download, a la "save link"?  Can we send some sort of
    # sensible name for the user to start from in her
    # browser's "save file" dialog?

    # Print the content-type header.
    print $query->header("application/x-tgz");

    # Generate the compressed tar archive to stdout.
    system("tar -C $tar_base_dir -c -z -f - $tar_source");
}
elsif($task eq $make_target_task)
{
    $session = $query->param($session_field);
    $session_dir = "$sessions_dir/$session";

    $target = $query->param($make_target_field);
    $proxy_target = $query->param($proxy_target_field);

    # Make the real target and the proxy target.
    makeSessionTarget($session_dir, $target);
    makeSessionTarget($session_dir, $proxy_target);

    writeMenu($session_dir, "whats-next.html");
}
elsif($task eq $batch_submit_form_task)
{
    # Print the content-type header.
    print $query->header;

    # Print the hmtl header.
    $title = "Identify your job";
    print $query->start_html(-title => $title);

    # Print banner.
    print $query->h1($title);

    # Start the form.
    print $query->startform(-action => $cgi_dispatch_url);

    # Table containing input fields for catch phrase and email address.
    print $query->table("<tr>",
			" <th>Catch phrase</th>",
			" <td>", $query->textfield(-name => $catch_phrase_field), "</td>",
			"</tr>");

    # Submit button.
    print $query->p($query->submit(-name => "Start job"));

    # Hidden fields to pass along information to the task that actually
    # starts the job.
    print $query->hidden($session_field);
    print $query->hidden($submit_file_field);
    print $query->hidden($proxy_target_field);
    $query->param($task_field, $batch_submit_job_task);
    print $query->hidden($task_field);

    # End form.
    print $query->endform;

    # End html.
    print $query->end_html;
}
elsif($task eq $batch_submit_job_task)
{
    # Make the submit file target in the session directory.
    $session = $query->param($session_field);
    $session_dir = "$sessions_dir/$session";
    makeSessionTarget($session_dir,
		      "batch-submit-file");

    # Read output of batch submission.
    open(BATCH_SUBMIT, "cd $session_dir && batch -f batch-submit-file 2>&1 |");
    while(<BATCH_SUBMIT>)
    {
	if(m/^job/)
	{
	    ($the_word_job, $job_number, $the_word_at, $date, $time) = split;
	}
    }
    close BATCH_SUBMIT;

    $catch_phrase = $query->param($catch_phrase_field);
    
    print STDERR "Submitted job $job_number on $date at $time with catch phrase $catch_phrase\n";

    # For the link back to the session from its entry in the
    # list of queued jobs.
    $session_menu_url = $cgi_dispatch_url
	. "?$task_field=$display_session_menu_task"
	. "&$session_field=$session";

    # Write job number, session, and catch phrase to catalog of jobs.
    # Note that we need to use percent as a separator here, since catch
    # phrases my have spaces in them.
    open(BATCH_MAP, ">> $queue_dir/batch_map");
    print BATCH_MAP "$job_number%$session%$catch_phrase%$date%$time\n";
    close BATCH_MAP;

    # Make the proxy target indicating that the queued job has been started.
    $proxy_target = $query->param($proxy_target_field);
    makeSessionTarget($session_dir, $proxy_target);

    # Display the session menu.
    writeMenu($session_dir, "whats-next.html");
}
elsif($task eq $condor_submit_form_task)
{
    # Print the content-type header.
    print $query->header;

    # Print the hmtl header.
    $title = "Identify your job";
    print $query->start_html(-title => $title);

    # Print banner.
    print $query->h1($title);

    # Start the form.
    print $query->startform(-action => $cgi_dispatch_url);

    # Table containing input fields for catch phrase and email address.
    print $query->table("<tr>",
			" <th>Catch phrase</th>",
			" <td>", $query->textfield(-name => $catch_phrase_field), "</td>",
			"</tr>",
			"<tr>",
			" <th>Your email address</th>",
			" <td>", $query->textfield(-name => $reply_email_field), "</td>",
			"</tr>");

    # Submit button.
    print $query->p($query->submit(-name => "Start job"));

    # Hidden fields to pass along information to the task that actually
    # starts the job.
    print $query->hidden($session_field);
    print $query->hidden($submit_file_field);
    print $query->hidden($proxy_target_field);
    $query->param($task_field, $condor_submit_job_task);
    print $query->hidden($task_field);

    # End form.
    print $query->endform;

    # End html.
    print $query->end_html;
}
elsif($task eq $condor_submit_job_task)
{
    # Make the submit file target in the session directory.
    # The email address is communicated through the environment.
    $session = $query->param($session_field);
    $session_dir = "$sessions_dir/$session";
    $reply_email = $query->param($reply_email_field);
    makeSessionTarget($session_dir,
		      "queue-submit-file REPLY_EMAIL=$reply_email");

    # Read output of condor submission using a pipe.
    open(CONDOR_SUBMIT, "condor_submit $session_dir/queue-submit-file |")
	or die ("Could not open pipe from condor_submit.\n");

    # Extract the cluster id from the condor_submit rebop.
    $job_id = "unknown";
    while(<CONDOR_SUBMIT>)
    {
	chop;
	if(m/cluster\s*([0-9]+)/) { $job_id = $1; }
    }

    close CONDOR_SUBMIT;

    # For the link back to the session from its entry in the
    # list of queued jobs.
    $session_menu_url = $cgi_dispatch_url
	. "?$task_field=$display_session_menu_task"
	. "&$session_field=$session";

    $submit_date = `date`;

    # Write catch-phrase and job id to catalog of jobs.
    $catch_phrase = $query->param($catch_phrase_field);
    open(HTML_BODY, ">>$queue_dir/job-list-body.html")
	or die("Could not open html body file.\n");

    print HTML_BODY "<tr>";
    print HTML_BODY " <td><a href='$session_menu_url'>$job_id</a></td>";
    print HTML_BODY " <td>$catch_phrase</td>";
    print HTML_BODY " <td>$submit_date</td>";
    print HTML_BODY "<tr>\n";

    close HTML_BODY;

    # For the interim, also write the $job_id, $session, $catch_phrase, and the
    # $reply_email address into the file mapping job_id to everything else.
    # Using % as a separator here, since catch phrases will have blanks.
    open(CLUSTER_MAP, ">>$queue_dir/cluster_map");
    print CLUSTER_MAP "$job_id%$session%$catch_phrase%$reply_email\n";
    close CLUSTER_MAP;

    # Make the proxy target indicating that the queued job has been started.
    $proxy_target = $query->param($proxy_target_field);
    makeSessionTarget($session_dir, $proxy_target);

    # Display the session menu.
    writeMenu($session_dir, "whats-next.html");
}
elsif($task eq $batch_list_task)
{
    # Open the file that keeps track of the connection between
    # batch jobs and the sessions that launched them.
    open(BATCH_MAP, "$queue_dir/batch_map")
	or die("Could not open batch-job-to-session file $queue_dir/batch_map.\n");
    # Read the file, generating an associative array mapping
    # batch job numbers to sessions and "catch phrases" supplied
    # by users to help identify sessions.
    while(<BATCH_MAP>)
    {
	chop;
	($job_number, $session, $catch_phrase) = split /%/;
	$job_session{$job_number} = $session;
	$job_catch_phrase{$job_number} = $catch_phrase;
    }
    close BATCH_MAP;

    # Print the content-type header.
    print $query->header;

    # Print the html header.
    print $query->start_html(-title=>'Sim queue');

    # Print a banner.
    print $query->h1("Sim queue");

    # Print banner for list of jobs in queue or running.
    # Looks like there's no useful history or log file for atd.
    print $query->h2("Current jobs");

    # Print head of table of jobs.
    print "<table border='1' cellspacing='1'>\n";
    print " <tr>\n";
    print "  <th>Job number</th>\n";
    print "  <th>Date</th>\n";
    print "  <th>Time</th>\n";
    print "  <th>Status</th>\n";
    print "  <th>Catch Phrase</th>\n";
    print "  <th>Session</th>\n";
    print " </tr>\n";

    # Print a row in the table for each job.
    # Open a pipe to read the output of atq.  For now, let's read all the
    # jobs and translate the queue designations.
    open(ATQ_OUTPUT, "atq |")
	or die("Could not open pipe from atq.\n");

    while(<ATQ_OUTPUT>)
    {
	# Split into fields.
	chop;
	($job_number, $date, $time, $queue_id) = split;
	
	# Translate the queue_id into a "status".
	if($queue_id =~ m/a/)
	{
	    $job_status = "waiting at-job";
	}
	elsif($queue_id =~ m/b/)
	{
	    $job_status = "waiting batch-job";
	}
	elsif($queue_id =~ m/=/)
	{
	    $job_status = "running";
	}

	# Get the session and catch-phrase for the job, if any.
	$session = $job_session{$job_number};
	if(! $session) {$session = "unknown";};
	$catch_phrase = $job_catch_phrase{$job_number};
	if(! $catch_phrase) {$catch_phrase = "unknown";};

	$session_menu_url = $cgi_dispatch_url
	    . "?$task_field=$display_session_menu_task"
	    . "&$session_field=$session";

	# Print row in the table for this line in atq output.
	print " <tr>\n";
	print "  <td>$job_number</td>\n";
	print "  <td>$date</td>\n";
	print "  <td>$time</td>\n";
	print "  <td>$job_status</td>\n";
	print "  <td>$catch_phrase</td>\n";
	print "  <td><a href='$session_menu_url'>$session</a></td>\n";
    }

    close ATQ_OUTPUT;

    # Print end of queue table.
    print "</table>\n";

    # Print table of sessions.
    print $query->h2("Sessions");

    # Print head of table of jobs.
    print "<table border='1' cellspacing='1'>\n";
    print " <tr>\n";
    print "  <th>Session</th>\n";
    print "  <th>Job number</th>\n";
    print "  <th>Catch Phrase</th>\n";
    print " </tr>\n";

    # Again open the file that keeps track of the connection between
    # batch jobs and the sessions that launched them.
    open(BATCH_MAP, "$queue_dir/batch_map")
	or die("Could not open batch-job-to-session file $queue_dir/batch_map.\n");
    # Read the file, generating an associative array mapping
    # batch job numbers to sessions and "catch phrases" supplied
    # by users to help identify sessions.
    while(<BATCH_MAP>)
    {
	chop;
	($job_number, $session, $catch_phrase) = split /%/;

	$session_menu_url = $cgi_dispatch_url
	    . "?$task_field=$display_session_menu_task"
	    . "&$session_field=$session";

	print " <tr>\n";
	print "  <td><a href='$session_menu_url'>$session</a></td>\n";
	print "  <td>$job_number</td>\n";
	print "  <td>$catch_phrase</td>\n";
	print " </tr>\n";
    }
    close BATCH_MAP;
    
    # Print end of session table.
    print "</table>\n";

    # Print link to main menu.
    $main_menu_url = $ENV{'MOLECULIZER_SERVER'} . "/moleculizer";
    print "<p><a href='$main_menu_url'>Main menu</a></p>\n";

    # Print html footer.
    print $query->end_html;
}
elsif($task eq $condor_list_task)
{
    # How will I make sure that the file exists (empty)?  At install time?
    open(CLUSTER_MAP, "$queue_dir/cluster_map")
	or die("Could not open cluster-to-session file $queue_dir/cluster_map.\n");
    while(<CLUSTER_MAP>)
    {
	chop;
	($cluster, $session, $catch_phrase, $reply_email) = split /%/;
	$cluster_session{$cluster} = $session;
	$cluster_catch_phrase{$cluster} = $catch_phrase;
	$cluster_reply_email{$cluster} = $reply_email;
    }
    close CLUSTER_MAP;

    # Open a pipe to read output of condor_q.
    open(CONDOR_Q, "condor_q|")
	or die ("Could not open pipe from condor_q.\n");

    # Read down through header line.
    while(<CONDOR_Q>)
    {
	if(m/ID/)
	{
	    last;
	}
    }

    # Print the content-type header.
    print $query->header;

    # Print the html header.
    print $query->start_html(-title=>'Sim queue');

    # Print a banner.
    print $query->h1("Sim queue");

    # Print banner for list of currently running jobs.
    print $query->h2("Current jobs");

    # Print head of table of jobs.
    # Omitting "priority" and "size" since they never seem right.
    print "<table border='1' cellspacing='1'>\n";
    print " <tr>\n";
    print "  <th>Cluster</th>\n";
    print "  <th>Submit Time</th>\n";
    print "  <th>Run Time</th>\n";
    print "  <th>Status</th>\n";
    print "  <th>Catch Phrase</th>\n";
    print "  <th>Reply Email</th>\n";
    print "  <th>Actions</th>\n";
    print " </tr>\n";

    # Print a row in the table for each job.
    while(<CONDOR_Q>)
    {
	chop;

	# Skip blank lines.
	if(m/^\s*$/)
	{
	    next;
	}
	# Skip the summary line at the end.
	elsif(m/running/)
	{
	    last;
	}
	else
	{
	    # Here "cluster" is what condor_q emits, namely cluster.process.
	    ($cluster, $owner, $submit_date, $submit_time,
	     $run_time, $status, $priority, $size, $command) = split;

	    $cluster =~ s/(.*)\..*/$1/;

	    $session = $cluster_session{$cluster};
	    $catch_phrase = $cluster_catch_phrase{$cluster};
	    $reply_email = $cluster_reply_email{$cluster};

	    # For the link back to the session.
	    $session_menu_url = $cgi_dispatch_url
		. "?$task_field=$display_session_menu_task"
		. "&$session_field=$session";

	    # For the remove action.
	    $remove_cluster_url = $cgi_dispatch_url
		. "?$task_field=$condor_remove_cluster_task"
		. "&$condor_cluster_field=$cluster"
		. "&$session_field=$session";

	    print " <tr>\n";
	    print "  <td><a href='$session_menu_url'>$cluster</a></td>\n";
	    print "  <td>$submit_date $submit_time</td>\n";
	    print "  <td>$run_time</td>\n";
	    print "  <td>$status</td>\n";
	    print "  <td>$catch_phrase</td>\n";
	    print "  <td>$reply_email</td>\n";
	    print "  <td><ul><li><a href=$remove_cluster_url>remove</a></li></ul></td>";
	    print " </tr>\n";
	}
    }

    # Print end of table of jobs.
    print "</table>\n";

    # Print a banner for the list of historical jobs.
    print $query->h2("Completed jobs");

    # Open a pipe to read output from condor_history.
    open(CONDOR_HISTORY, "condor_history|")
	or die("Could not open pipe from condor_history.\n");

    # Read down through the header line.
    while(<CONDOR_HISTORY>)
    {
	if(m/ID/)
	{
	    last;
	}
    }

    # Print head of table of historical jobs.
    print "<table border='1' cellspacing='1'>\n";
    print " <tr>\n";
    print "  <th>Cluster</th>\n";
    print "  <th>Submit Time</th>\n";
    print "  <th>Run Time</th>\n";
    print "  <th>Status</th>\n";
    print "  <th>Completion Time</th>\n";
    print "  <th>Catch Phrase</th>\n";
    print "  <th>Reply Email</th>\n";
    print " </tr>\n";

    # Print a row in the table for each historical job.
    while(<CONDOR_HISTORY>)
    {
	($cluster, $owner, $submit_date, $submit_time,
	 $run_time, $status, $complete_date, $complete_time, $command) = split;

	$cluster =~ s/(.*)\..*/$1/;

	$session = $cluster_session{$cluster};
	$catch_phrase = $cluster_catch_phrase{$cluster};
	$reply_email = $cluster_reply_email{$cluster};

	# For the link back to the session.
	$session_menu_url = $cgi_dispatch_url
	    . "?$task_field=$display_session_menu_task"
	    . "&$session_field=$session";

	# It looks like condor_history truncates the command, but always
	# starts at the beginning, so that you just get the start of the path.
	# So it doesn't do any good to try to 'doctor' $command here.

	print " <tr>\n";
	if($session)
	{
	    # Print link to session only if there is a session to go to.
	    print "  <td><a href='$session_menu_url'>$cluster</a></td>\n";
	}
	else
	{
	    print "  <td>$cluster</td>\n";
	}
	print "  <td>$submit_date $submit_time</td>\n";
	print "  <td>$run_time</td>\n";
	print "  <td>$status</td>\n";
	print "  <td>$complete_date $complete_time</td>\n";
	print "  <td>$catch_phrase</td>\n";
	print "  <td>$reply_email</td>\n";
	print " </tr>\n";
    }

    # Print end of table of jobs.
    print "</table>\n";

    # Print link to main menu.
    $main_menu_url = $ENV{'MOLECULIZER_SERVER'} . "/moleculizer";
    print "<p><a href='$main_menu_url'>Main menu</a></p>\n";

    # Print html footer.
    print $query->end_html;
}
elsif($task eq $condor_remove_cluster_task)
{
    # Get the cluster.
    $cluster = $query->param($condor_cluster_field);

    # Invoke condor_remove on the cluster.
    print STDERR "Removing condor cluster $cluster.\n";
    system("condor_rm $cluster >/dev/null 2>&1");

    # Display menu of associated session.
    $session = $query->param($session_field);
    $session_dir = "$sessions_dir/$session";
    writeMenu($session_dir, "whats-next.html");
}
else
{
    # Print the content-type header.
    print $query->header;

    # Print the html header.
    print $query->start_html(-title=>'Moleculizer server error!');

    # Print a banner.
    print $query->h1("Sorry!");

    print $query->p("The \'$task\' feature has not yet been implemented.");

    # Print the html footer.
    print $query->end_html;
}
